<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Miguel Palhas | @naps62 - Miguel Palhas | @naps62</title>
    <subtitle>Software Developer | Elixir | Ruby | Rust | DevOps | Chess</subtitle>
    <link href="https://naps62.com/posts/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://naps62.com/posts/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2020-07-27T00:00:00+00:00</updated>
    <id>https://naps62.com/posts/atom.xml</id>
    <entry xml:lang="en">
        <title>A knowledge base with Vim, Fzf and Ripgrep</title>
        <published>2020-07-27T00:00:00+00:00</published>
        <updated>2020-07-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/knowledge-base/" type="text/html"/>
        <id>https://naps62.com/posts/knowledge-base/</id>
        
        <content type="html">&lt;p&gt;I&#x27;ve been trying to grow my own knowledge base for a long time now, by keeping
track of multiple notes taken from books, quotes, and other sources of
knowledge.&lt;&#x2F;p&gt;
&lt;p&gt;Now, and after a few iterations, I&#x27;m moving that to a more Unix-oriented
approach, which I&#x27;m presenting here.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR: I built my own terminal-based Zettelkasten system. Checkout the
Readme and source code &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;zk&quot;&gt;at Github&lt;&#x2F;a&gt;.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;my-sources&quot;&gt;My sources&lt;a class=&quot;zola-anchor&quot; href=&quot;#my-sources&quot; aria-label=&quot;Anchor link for: my-sources&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m both the worst person at note taking, and the kind of person that needs
note-taking the most. My memory sucks, but so does my caligraphy.&lt;&#x2F;p&gt;
&lt;p&gt;Like most other people, I consume information from several different sources. Here&#x27;s a few:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Throughout my work (google searches, stack overflow, conversations, etc)&lt;&#x2F;li&gt;
&lt;li&gt;Books, which I mostly consume with my Kindle, and sometimes &lt;a href=&quot;https:&#x2F;&#x2F;www.audible.com&quot;&gt;Audible&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Articles (via both &lt;a href=&quot;https:&#x2F;&#x2F;feedly.com&quot;&gt;Feedly&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;app.getpocket.com&quot;&gt;Pocket&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Podcasts&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;You may notice that I&#x27;m very digital-oriented. I do that both as a way to live
a more minimalistic lifestyle (less physical items + easier to travel), but also
to be able to retrieve information more easily.&lt;&#x2F;p&gt;
&lt;p&gt;Using my Kindle allows me to highlight any quote I want to save for later. Same
goes for my news feeds. Audible also has a clipping feature, although it&#x27;s
a bit more awkward to use, and doesn&#x27;t provide any kind of programatic access to
text. For more ad-hoc situations, such as a conversation, a quick note on
&lt;a href=&quot;https:&#x2F;&#x2F;todoist.com&quot;&gt;Todoist&lt;&#x2F;a&gt; also works really well.&lt;&#x2F;p&gt;
&lt;p&gt;Throughout my day, I want the ability to quickly highlight pieces of
information, with the least amount of friction possible.&lt;&#x2F;p&gt;
&lt;p&gt;Periodically, usually at the end of each month, I&#x27;ll go through all new notes,
and organize them into my own knowledge base, with two main goals in mind:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;To condense any potentially useful knowledge in an accessible way&lt;&#x2F;li&gt;
&lt;li&gt;To go through everything a second time (or more), to consolidate knowledge.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Whenever I, later on, want to remind myself of a particular concept, or even
find a particular quote or definition to include in a talk I&#x27;m building, I&#x27;ll
often go back to this knowledge base. I&#x27;ll also make a point to revisit notes
for a particular book at some point in the future, doing a slightly informal
version of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spaced_repetition&quot;&gt;Spaced
Repetition&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So here&#x27;s how I built this knowledge base:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;first-draft-notion&quot;&gt;First draft: Notion&lt;a class=&quot;zola-anchor&quot; href=&quot;#first-draft-notion&quot; aria-label=&quot;Anchor link for: first-draft-notion&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;My first version of this knowledge base was built with
&lt;a href=&quot;https:&#x2F;&#x2F;notion.so&quot;&gt;Notion&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Notion is a text editor with superpowers. It allows me to create whatever
hierarchy I want. It supports full-text search. And works on all platforms
without any extra effort, meaning I can have my knowledge available at all
times.&lt;&#x2F;p&gt;
&lt;p&gt;I can create a page for each book I read:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;knowledge-base&#x2F;.&#x2F;notion-index.png&quot; alt=&quot;notion index&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;And within those pages, I can use a markdown-like syntax to list highlights:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;knowledge-base&#x2F;.&#x2F;notion-thinking-systems.png&quot; alt=&quot;notion systems&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;But this didn&#x27;t fit my own workflow very easily.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m a long-time linux user, and I&#x27;ve come to learn how to be productive with
tools that I have available on my terminal. So it made sense to me that my
knowledge base should be accessible on my terminal as well, and taking advantage
of the tools that I already know and love.&lt;&#x2F;p&gt;
&lt;p&gt;This also allowed me to build some custom features that I&#x27;ve been wanting for
some time.&lt;&#x2F;p&gt;
&lt;p&gt;Which is why I build my own zettelkasten setup.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-zettelkasten&quot;&gt;A Zettelkasten&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-zettelkasten&quot; aria-label=&quot;Anchor link for: a-zettelkasten&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;a knowledge management and note-taking method used in research and study&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Zettelkasten&quot;&gt;Wikipedia&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve actually only learned of this name recently, when reading &lt;a href=&quot;https:&#x2F;&#x2F;superorganizers.substack.com&#x2F;p&#x2F;how-to-build-a-learning-machine&quot;&gt;a blog
post&lt;&#x2F;a&gt; that ended up being one of the inspirations for this
work.&lt;&#x2F;p&gt;
&lt;p&gt;A zettelkasten is a personal knowledge base. The name is of german origin,
&amp;quot;Zettel&amp;quot; meaning note, and &amp;quot;Kasten&amp;quot; meaning box.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s not a concrete methodology, or a specific way of organizing information.
It&#x27;s nothing more than a metaphorical box of notes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-unix-based-zettelkasten&quot;&gt;A unix-based zettelkasten&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-unix-based-zettelkasten&quot; aria-label=&quot;Anchor link for: a-unix-based-zettelkasten&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To this end, I ended up building my own set of scripts to manage a knowledge
base, by stitching together multiple tools that are already part of my daily
workflow.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;notes-as-markdown&quot;&gt;Notes as markdown&lt;a class=&quot;zola-anchor&quot; href=&quot;#notes-as-markdown&quot; aria-label=&quot;Anchor link for: notes-as-markdown&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Each note is represented as a single markdown file.&lt;&#x2F;p&gt;
&lt;p&gt;Markdown is intuitive enough to use in the context of a terminal, and syntax
highglighting allows me to leverage it for a few extra things, as we&#x27;ll see&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s an example of a real note from my knowledge base:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;markdown&quot; class=&quot;language-markdown &quot;&gt;&lt;code class=&quot;language-markdown&quot; data-lang=&quot;markdown&quot;&gt;# Recalcitrance

Resistance towards helpfulness or evolution

https:&amp;#x2F;&amp;#x2F;www.dictionary.com&amp;#x2F;browse&amp;#x2F;recalcitrance

@superintelligence @nick-bostrom @book
#definition #ai
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a short one. A definition of a word. One that I learned while reading
&lt;a href=&quot;https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;20527133-superintelligence&quot;&gt;Superintelligence&lt;&#x2F;a&gt;
a few years ago.&lt;&#x2F;p&gt;
&lt;p&gt;I chose to use hashtags, such as &lt;code&gt;#definition&lt;&#x2F;code&gt; to tag each note as I see fit,
but also to specify sources using &lt;code&gt;@&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This allows me build tooling to search for both tags and sources, and quickly
find what I&#x27;m looking for.&lt;&#x2F;p&gt;
&lt;p&gt;This note is also not static. If I come back to it, I&#x27;m free to edit it as I see
fit, or even add new tags, if I want to relate it with some newfound idea
present somewhere else in the base.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;see-it-in-action&quot;&gt;See it in action&lt;a class=&quot;zola-anchor&quot; href=&quot;#see-it-in-action&quot; aria-label=&quot;Anchor link for: see-it-in-action&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Here&#x27;s a quick rundown of what I have so far:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The knowledge base is pointed to by &lt;code&gt;$ZK_PATH&lt;&#x2F;code&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;zk new &amp;lt;title&amp;gt;&lt;&#x2F;code&gt; creates a new note;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;zk tags&lt;&#x2F;code&gt; starts an interactive fuzzy search across all existing tags;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;zk sources&lt;&#x2F;code&gt; does the same thing, but for sources instead;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;zk search&lt;&#x2F;code&gt; starts a full text search on the entire knowledge base.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;knowledge-base&#x2F;.&#x2F;zk-in-action.gif&quot; alt=&quot;zk in action&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;PS: As I mentioned, most of this is inspired by &lt;a href=&quot;https:&#x2F;&#x2F;superorganizers.substack.com&#x2F;p&#x2F;how-to-build-a-learning-machine&quot;&gt;this
article&lt;&#x2F;a&gt;. The author &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sirupsen&#x2F;zk&quot;&gt;built and open-sourced&lt;&#x2F;a&gt; his
own system using very similar tools as the ones I did.&lt;&#x2F;p&gt;
&lt;p&gt;Curious about what&#x27;s underneath all this? It&#x27;s actually fairly simple:&lt;&#x2F;p&gt;
&lt;h4 id=&quot;git&quot;&gt;Git&lt;a class=&quot;zola-anchor&quot; href=&quot;#git&quot; aria-label=&quot;Anchor link for: git&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The knowledge base itself is a &lt;code&gt;git&lt;&#x2F;code&gt; repo. Assuming you&#x27;re a developer (or
similar role), this should not require any further explanation. ðŸ˜„&lt;&#x2F;p&gt;
&lt;h4 id=&quot;vim&quot;&gt;Vim&lt;a class=&quot;zola-anchor&quot; href=&quot;#vim&quot; aria-label=&quot;Anchor link for: vim&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;My editor of choice. Since this is, at the moment, made for personal use,
I haven&#x27;t focused on supporting anything else, as I have no need for it&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ripgrep&quot;&gt;Ripgrep&lt;a class=&quot;zola-anchor&quot; href=&quot;#ripgrep&quot; aria-label=&quot;Anchor link for: ripgrep&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Remember what I said about searching for tags or sources?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;BurntSushi&#x2F;ripgrep&quot;&gt;&lt;code&gt;ripgrep&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is an extremely fast full-text search tool.&lt;&#x2F;p&gt;
&lt;p&gt;I can build a search for tags (words starting with &lt;code&gt;#&lt;&#x2F;code&gt;) with something like the
following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;rg --only-matching &amp;quot;#[\w\-_]{3,}&amp;quot; --type md ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;fzf&quot;&gt;Fzf&lt;a class=&quot;zola-anchor&quot; href=&quot;#fzf&quot; aria-label=&quot;Anchor link for: fzf&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Fzf is a fuzzy-finder which, when coupled with ripgrep, provides a great
interactive and real-time search environment right in my terminal&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up&quot; aria-label=&quot;Anchor link for: wrapping-up&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;This system is still in its early stages (in fact, I&#x27;m still in the process of
migrating some notes from Notion).
It does look very promising though, since I find myself using it a lot more
often just because it sits right there in my terminal.&lt;&#x2F;p&gt;
&lt;p&gt;Check out the source code on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;zk&quot;&gt;GitHub&lt;&#x2F;a&gt;, or &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;naps62&quot;&gt;let me know&lt;&#x2F;a&gt; your
thoughts about all this. ðŸ‘‹&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Focused Writing in Vim</title>
        <published>2020-06-15T00:00:00+00:00</published>
        <updated>2020-06-15T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/focused-writing-in-vim/" type="text/html"/>
        <id>https://naps62.com/posts/focused-writing-in-vim/</id>
        
        <content type="html">&lt;p&gt;I&#x27;ve been working on getting an improved focus environment to write blog posts in. There&#x27;s a lot of &amp;quot;Focus mode&amp;quot;
features out there in pretty much every editor. But in Vim, I wanted to piece together a few different things, and also
make some additions of my own.&lt;&#x2F;p&gt;
&lt;p&gt;I use a 4K monitor, which is great for gaming &amp;amp; programming, but kind of overkill for writing blog posts. I don&#x27;t
want all that real estate.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-end-result&quot;&gt;The end result&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-end-result&quot; aria-label=&quot;Anchor link for: the-end-result&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;So here&#x27;s the gist of what I achieved (or a video right below, showcasing the final thing). Running &lt;code&gt;:Focus&lt;&#x2F;code&gt; on Vim does
a bunch of different things:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Center &amp;amp; focus the 80-wide lines of content;&lt;&#x2F;li&gt;
&lt;li&gt;Increase the font size... a lot;&lt;&#x2F;li&gt;
&lt;li&gt;Hide away all the visual noise (statusbars, line numbers, autocomplete, window manager, and so on);&lt;&#x2F;li&gt;
&lt;li&gt;Disable editor features targeted at programming (looking at you, autocomplete);&lt;&#x2F;li&gt;
&lt;li&gt;&lt;em&gt;Maybe&lt;&#x2F;em&gt; have a Table of Contents on the left side, for easy navigation on long posts.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;div &gt;
  &lt;iframe
    src=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;8dLIDBKkbCI&quot;
    webkitallowfullscreen
    mozallowfullscreen
    allowfullscreen
  &gt;
  &lt;&#x2F;iframe&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;All of this is achieved with a few existing vim plugins, all tied together in a single &lt;code&gt;Focus()&lt;&#x2F;code&gt; function. There&#x27;s also
some bits that need to go beyond Vim, such as increasing font size, for instance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-road-towards-it&quot;&gt;The road towards it&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-road-towards-it&quot; aria-label=&quot;Anchor link for: the-road-towards-it&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start with the easy stuff. Creating a &lt;code&gt;:Focus&lt;&#x2F;code&gt; command is pretty straightforward.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;let g:focused = 0
function! Focus()
  if g:focused == 0
    &amp;quot; magically enable focus stuff
    let g:focused = 1
  else
    &amp;quot; disable all of it again
    let g:focused = 1
  endif
endfunction
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can even have our function work as a toggle. Calling it a second time will (ideally) undo all the evil we did.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s now go through all the stuff we can enable in that if statement. Feel free to cherry-pick whichever ones work for
you. That&#x27;s the beauty of using custom vim code instead of a one-size-fits-all solution.&lt;&#x2F;p&gt;
&lt;p&gt;PS: For each section, I&#x27;ll include the vimscript code necessary to enable it. For disabling it (the &lt;code&gt;else&lt;&#x2F;code&gt; part of
the &lt;code&gt;if&lt;&#x2F;code&gt; statement), check out the full code in &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;naps62&#x2F;20e71350443191dd002c6dc640eef0c4&quot;&gt;this gist&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-goyo-distraction-free-mode&quot;&gt;1. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;junegunn&#x2F;goyo.vim&quot;&gt;Goyo&lt;&#x2F;a&gt; - Distraction-free mode&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-goyo-distraction-free-mode&quot; aria-label=&quot;Anchor link for: 1-goyo-distraction-free-mode&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This plugin adds a distraction-free mode to Vim, which hides most the of clutter already.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;&amp;quot; enable distraction-free with a 120 column wide buffer
:Goyo 120
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;2-limelight-for-even-more-focus&quot;&gt;2. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;junegunn&#x2F;limelight.vim&quot;&gt;Limelight&lt;&#x2F;a&gt; - for even more focus&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-limelight-for-even-more-focus&quot; aria-label=&quot;Anchor link for: 2-limelight-for-even-more-focus&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Built by the same author, this goes one step further, and dims down all content but the currently highlighted paragrah.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;:Limelight
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;3-voom&quot;&gt;3. &lt;a href=&quot;https:&#x2F;&#x2F;www.vim.org&#x2F;scripts&#x2F;script.php?script_id=2657&quot;&gt;VOoM&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-voom&quot; aria-label=&quot;Anchor link for: 3-voom&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Yet another package. This one adds a Table of Contents to the left of your content buffer. It builds an index for markdown and other standard content formats, making it pretty useful for navigating large files.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;&amp;quot; enable sidebar TOC for a markdown file
:VOoM markdown
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;4-disable-additional-vim-clutter&quot;&gt;4. Disable additional vim clutter&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-disable-additional-vim-clutter&quot; aria-label=&quot;Anchor link for: 4-disable-additional-vim-clutter&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now for the actual custom stuff. These are a few small settings that I normally use on Vim, but wanted to disable while
in focus mode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;&amp;quot; disable highlighting of the current line
set nocursorline

&amp;quot; disable highlighting of the current column
set nocursorcolumn

&amp;quot; even though Goyo hides the status bar, a small `-- INSERT --`
&amp;quot; was still showing up in the corner.
&amp;quot; This gets rid of that as well
set noshowmode
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;5-always-centered-cursor&quot;&gt;5. Always-centered cursor&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-always-centered-cursor&quot; aria-label=&quot;Anchor link for: 5-always-centered-cursor&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This one is probably the most hacky thing on this list. Sorry, but I couldn&#x27;t resist&lt;&#x2F;p&gt;
&lt;p&gt;I wanted the current line to always be vertically centered as well.&lt;&#x2F;p&gt;
&lt;p&gt;Using &lt;code&gt;set scrolloff=20&lt;&#x2F;code&gt; would tell vim to scroll 20
lines past the End-of-File. But while writing, the current text would still end at the bottom of the screen, unless
I manually scrolled down those extra lines.&lt;&#x2F;p&gt;
&lt;p&gt;The trick is to override the default navigation mappings, and combine them with &lt;code&gt;zz&lt;&#x2F;code&gt; which brings the cursor current
line to the vertical center of the screen:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;:nmap j jzz
:nmap k kzz
:nmap G Gzz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;j&lt;&#x2F;code&gt;, &lt;code&gt;k&lt;&#x2F;code&gt; and &lt;code&gt;G&lt;&#x2F;code&gt; are the movements I use most often. Appending &lt;code&gt;zz&lt;&#x2F;code&gt; to them automatically keeps my current focus right
at the center. It&#x27;s not perfect, but it&#x27;s close enough.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;6-hiding-tmux-s-status-bar&quot;&gt;6. Hiding tmux&#x27;s status bar&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-hiding-tmux-s-status-bar&quot; aria-label=&quot;Anchor link for: 6-hiding-tmux-s-status-bar&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Since I always run Vim inside a tmux session, I wanted to hide that as well. This one is actually pretty simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;:silent !tmux set status off
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;7-increase-font-size&quot;&gt;7. Increase font size&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-increase-font-size&quot; aria-label=&quot;Anchor link for: 7-increase-font-size&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This was the final piece, and another trick I had to use. However, without a bigger font size, everything before this
would really suck. 14pt fonts centered on a 4K monitor isn&#x27;t really that useful, nor comfortable&lt;&#x2F;p&gt;
&lt;p&gt;I use &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alacritty&#x2F;alacritty&quot;&gt;alacritty&lt;&#x2F;a&gt;. Like most other terminals, there are shortcuts to zoom
in&#x2F;out, and reset. In my case, I have those set to &lt;code&gt;Ctrl+&#x27;&lt;&#x2F;code&gt;, &lt;code&gt;Ctrl+-&lt;&#x2F;code&gt; and &lt;code&gt;Ctrl+0&lt;&#x2F;code&gt;, respectively. In &lt;code&gt;alacritty.yml&lt;&#x2F;code&gt;&#x27;s
config file, that translates to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;key_bindings:
  - { key: Key0, mods: Control, action: ResetFontSize }
  - { key: Apostrophe, mods: Control, action: IncreaseFontSize }
  - { key: Subtract, mods: Control, action: DecreaseFontSize }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As far as I could tell, there is no command line API that I could call to achieve the same effects, so I went with the
keyboard shortcuts. Using &lt;code&gt;xdotool&lt;&#x2F;code&gt;, it&#x27;s easy to send those keystroke signals to the terminal window, with a single
command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;:silent !xdotool key --repeat 10 Ctrl+apostrophe
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is using &lt;a href=&quot;https:&#x2F;&#x2F;jlk.fjfi.cvut.cz&#x2F;arch&#x2F;manpages&#x2F;man&#x2F;xdotool.1.en&quot;&gt;xdotool&lt;&#x2F;a&gt; to send a zoom-in shortcut signal to the active window, 10 times.
A similar &lt;code&gt;xdotool key Ctrl+0&lt;&#x2F;code&gt; can be used to get back to the default zoom level at the end.&lt;&#x2F;p&gt;
&lt;p&gt;10 was just an arbitrary number that got me to a visually comfortable level.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up&quot; aria-label=&quot;Anchor link for: wrapping-up&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I used this full setup for the first time while writing this post. It has a few rough edges that I&#x27;ll still be
improving on in the future, but it&#x27;s already proven extremely helpful.
Check out the full &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;naps62&#x2F;20e71350443191dd002c6dc640eef0c4&quot;&gt;vim code here&lt;&#x2F;a&gt;, or let me know on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;naps62&quot;&gt;twitter&lt;&#x2F;a&gt; if you have any thoughts on how to improve this.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Continuous Stuff with GitHub Actions</title>
        <published>2020-03-30T00:00:00+00:00</published>
        <updated>2020-03-30T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/continuous-stuff-with-github-actions/" type="text/html"/>
        <id>https://naps62.com/posts/continuous-stuff-with-github-actions/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;This post was originally posted on my company&#x27;s blog. Feel free to check out the &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.com&#x2F;blog&#x2F;posts&#x2F;continuous-stuff-with-github-actions&quot;&gt;original&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Last year, I took on the task of improving the continuous process over at &lt;a href=&quot;https:&#x2F;&#x2F;utrust.com&quot;&gt;Utrust&lt;&#x2F;a&gt;. We weren&#x27;t really happy with
the amount of work that went into our releases, and I was looking for a more agile approach, where everyone from
developers to the QA team could do their part with low friction.&lt;&#x2F;p&gt;
&lt;p&gt;Coincidentally, that project started right around the same time GitHub Actions went into public beta. Some of our
problems were related to shortcomings on our existing CI solution, so it felt right to see what GitHub had to offer.&lt;&#x2F;p&gt;
&lt;p&gt;I ended up pleasantly surprised. But first, let&#x27;s talk about what exactly was wrong with our previous CI.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shortcomings-of-traditional-cis&quot;&gt;Shortcomings of traditional CIs&lt;a class=&quot;zola-anchor&quot; href=&quot;#shortcomings-of-traditional-cis&quot; aria-label=&quot;Anchor link for: shortcomings-of-traditional-cis&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;ve worked with a fair amount of CIs over the years...&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;continuous-stuff-with-github-actions&#x2F;.&#x2F;cis.png&quot; alt=&quot;CIs&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;HalfWidthImage img={ImgCI} alt=&quot;CIs&quot; large={50} small={50} &#x2F;&gt;
&lt;p&gt;There was always something that seemed a bit off, though. They all do one simple, but very useful, thing: they react to
commits&lt;&#x2F;p&gt;
&lt;p&gt;The main use case for this is the now common one: to run tests for every new version of your code. But any kind of
automated task can be triggered, really. A deploy is very common as well, or a preview build for testing.&lt;&#x2F;p&gt;
&lt;p&gt;But a lot of these automations shouldn&#x27;t necessarily need a commit. They are not triggered by changes in the code.
Deploys might be triggered by some higher-level decision, or a QA team manually approving the latest version, which was
committed days ago.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;not-everything-is-a-commit&quot;&gt;Not everything is a commit&lt;a class=&quot;zola-anchor&quot; href=&quot;#not-everything-is-a-commit&quot; aria-label=&quot;Anchor link for: not-everything-is-a-commit&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;This led to the common practice of creating &amp;quot;special&amp;quot; ways to trigger these commits. In &lt;a href=&quot;http:&#x2F;&#x2F;circleci.com&#x2F;&quot;&gt;CircleCI&lt;&#x2F;a&gt;, for
example, you&#x27;d do something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;workflows:
  build:
    release:
      - deploy_to_staging:
          filters:
            branches:
              only:
                - staging
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this, commits to the &lt;code&gt;staging&lt;&#x2F;code&gt; branch would trigger a deploy to staging. Seems simple enough. But now you need
a branch for every single environment. And probably quite a few &lt;code&gt;push -f&lt;&#x2F;code&gt; commands, or similar git sorceries to force
a commit from your normal workflow into a branch whose history is messier than the plot of &lt;a href=&quot;https:&#x2F;&#x2F;www.imdb.com&#x2F;title&#x2F;tt0390384&#x2F;&quot;&gt;Primer&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;github-api-to-the-rescue&quot;&gt;GitHub API to the rescue&lt;a class=&quot;zola-anchor&quot; href=&quot;#github-api-to-the-rescue&quot; aria-label=&quot;Anchor link for: github-api-to-the-rescue&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The problem here is that we&#x27;re solving things the wrong way. A deploy is not a commit. It&#x27;s a deploy.&lt;&#x2F;p&gt;
&lt;p&gt;And GitHub actually has a &lt;a href=&quot;https:&#x2F;&#x2F;developer.github.com&#x2F;v3&#x2F;repos&#x2F;deployments&#x2F;&quot;&gt;Deployments API&lt;&#x2F;a&gt; that encapsulates that exact concept. You can tell
GitHub to create a deployment, by providing a certain git reference, an environment to which you want to deploy, and
other optional parameters.&lt;&#x2F;p&gt;
&lt;p&gt;GitHub will then collect this and build a history of all the deploys you requested, and the status of each one (which
can be updated using the same API).&lt;&#x2F;p&gt;
&lt;p&gt;This API won&#x27;t really do anything by itself, though. It builds a nice log, but that&#x27;s about it. You can subscribe to
webhooks from this API though.&lt;&#x2F;p&gt;
&lt;p&gt;So any 3rd party service could theoretically listen to these webhooks, and process the deployment you requested, instead
of forcing you the come up with fancy ways to commit things in a particular way.&lt;&#x2F;p&gt;
&lt;p&gt;None of these CIs seem to do that, though. And that&#x27;s why GitHub Actions are so different.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;github-action-triggers&quot;&gt;GitHub Action triggers&lt;a class=&quot;zola-anchor&quot; href=&quot;#github-action-triggers&quot; aria-label=&quot;Anchor link for: github-action-triggers&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;GitHub&#x27;s new toy allows us to build jobs that can be triggered &lt;a href=&quot;https:&#x2F;&#x2F;help.github.com&#x2F;en&#x2F;actions&#x2F;reference&#x2F;events-that-trigger-workflows&quot;&gt;in a variety of ways&lt;&#x2F;a&gt;. You can
have the traditional &amp;quot;on every push&amp;quot; jobs, but also more fancy stuff, such as &amp;quot;on every deployment created&amp;quot;, or even &amp;quot;on
every commit to an issue&amp;quot;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;name: GitHub Action Example

on: [deployment]

jobs:
  steps:
    # ...
    - run: npm run deploy ${{ github.event.deployment.environment }}
    # ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This sample does not rely on a &lt;code&gt;git push&lt;&#x2F;code&gt; in any way. All that is needed to trigger it is to call the Deployments API,
and the rest of the job can pick up parameters from the webhook&#x27;s data to figure out what to do, such as what
environment to deploy to.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;preventing-redundant-builds&quot;&gt;Preventing redundant builds&lt;a class=&quot;zola-anchor&quot; href=&quot;#preventing-redundant-builds&quot; aria-label=&quot;Anchor link for: preventing-redundant-builds&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;One other thing that other CIs also aimed to achieve, is to optimize usage by preventing branches from triggering builds
unless a Pull Request is open for them. The rationale here is that a work-in-progress branch rarely needs CI feedback,
and would only waste resources. This is often a configurable option in CI settings. But with GitHub action triggers, we
can do a bit more than that, by having that configuration in the source code itself:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;name: GitHub Action Example

on:
  push:
    branches:
      - master
    tags:
      - &amp;#x27;*&amp;#x27;
  pull_request:
    types: [opened, synchronize]

jobs:
  # ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We might want to always trigger builds for the master branch, or for every tag that is created. But for pull requests
(which have their own webhook, and therefore, trigger), we can specify that only creation or updates to those Pull
Requests&#x27; history should trigger the job.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;manual-workflows-with-comments&quot;&gt;Manual workflows with comments&lt;a class=&quot;zola-anchor&quot; href=&quot;#manual-workflows-with-comments&quot; aria-label=&quot;Anchor link for: manual-workflows-with-comments&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We can also react to comments on the Pull Request itself, which can be useful if you want a more seamless integration of
some features.&lt;&#x2F;p&gt;
&lt;p&gt;In my case, I wanted to deploy a preview version of Pull Requests to our frontend application. It wasn&#x27;t efficient to
do this for every single PR though (only a small subset of them actually need this), so we went with this instead:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;continuous-stuff-with-github-actions&#x2F;.&#x2F;github-actions-comment.png&quot; alt=&quot;Comments triggering GitHub Action&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Whenever someone comments on a Pull Request and includes the word &amp;quot;preview&amp;quot;, an Action will be triggered which will take
that branch and deploy a live preview of it, so it can be easily tested.&lt;&#x2F;p&gt;
&lt;p&gt;The ease with which this was all done by just using different hooks made this very pleasant to work with.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;reusable-actions&quot;&gt;Reusable actions&lt;a class=&quot;zola-anchor&quot; href=&quot;#reusable-actions&quot; aria-label=&quot;Anchor link for: reusable-actions&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;A second issue I often had with previous CIs was the difficulty, or complete lack of a way to create reusable parts of
your pipeline, so you can compose other jobs with them.&lt;&#x2F;p&gt;
&lt;p&gt;Yes, YAML allows you to reuse blocks...&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;
component: &amp;amp;component
  foo: bar

extension: *component
  baz: biz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;... but they don&#x27;t look pretty, especially once they start to grow. And if you, like me, have any experience mantaining
a large project with multiple CI worflows and configurations, you probably know that things tend to get out of hand.
It&#x27;s always a single YAML file, which can grow to hundreds of lines. You can reuse blocks of YAML, but they may end up
running under different contexts (e.g.: different docker images, different dependencies installed, etc).&lt;&#x2F;p&gt;
&lt;p&gt;CircleCI did introduce the concept of &lt;a href=&quot;https:&#x2F;&#x2F;circleci.com&#x2F;orbs&#x2F;&quot;&gt;Orbs&lt;&#x2F;a&gt; in their ecosystem, which attempts to tackle this. However,
their reusability is limited.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;# circleci.yml

push_s3:
  executor: ubuntu
  steps:
    - my-custom-org&amp;#x2F;my-custom-command:
        arg: &amp;#x27;foo&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a trimmed-down example, where a custom command is encapsulated in a &lt;code&gt;my-custom-orb&lt;&#x2F;code&gt; Orb. You may notice that the
main config file is the one who specificies the execution environment (ubuntu, in this case). So, if the Orb tries to
&lt;code&gt;yum install git&lt;&#x2F;code&gt;, this would fail, because that package manager isn&#x27;t used in Ubuntu.&lt;&#x2F;p&gt;
&lt;p&gt;So you end up with a mess of a script that does a whole bunch of magic just to figure out how to install the
dependencies it needs. Check out &lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;continuous-stuff-with-github-actions&#x2F;orb-awscli&quot;&gt;the actual source code&lt;&#x2F;a&gt; for the official Orb that installs &lt;code&gt;awscli&lt;&#x2F;code&gt; on
your jobs. It&#x27;s a bit of a mess, isn&#x27;t it?&lt;&#x2F;p&gt;
&lt;p&gt;You could delegate everything into a ready-to-go Docker container, and run whatever you need in there. But then you lose
access to the overall filesystem of your original job, where you already cloned your project and created a bunch of
useful artifacts. Not great, either.&lt;&#x2F;p&gt;
&lt;p&gt;GitHub Actions solves this by allowing you to write reusable actions in two different ways. None of those are YAML, and
both of those are way better:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;As a Docker container, but one that will automatically mount the local filesystem into it. You get access to
everything your job has been doing so far and, since it&#x27;s docker, you can pretty much install whatever dependencies
you need, without caring about polluting the host job.&lt;&#x2F;li&gt;
&lt;li&gt;In JavaScript. Which, as you may know, is a pretty powerful tool.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Here&#x27;s a basic GitHub Actions job:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;name: Demo
on: [push]

jobs:
  test:
    runs-on: ubuntu-latest

  steps:
    - name: Checkout repo
      uses: actions&amp;#x2F;checkout@v2

    - name: Install deps
      run: npm install

    - name: Run tests
      run: npm run test
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first step here, &lt;code&gt;actions&#x2F;checkout@v2&lt;&#x2F;code&gt; is what checks out your repo to the local filesystem. And it&#x27;s actually done
in JavaScript! The syntax, as you may tell, looks suspiciously like a link to a GitHub repo. And, well, it is. If you
check &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;checkout&#x2F;tree&#x2F;v2.0.0&quot;&gt;release &lt;code&gt;v2&lt;&#x2F;code&gt; on that repository&lt;&#x2F;a&gt;, you&#x27;ll see the actual JS code used to clone your repo into
the action.&lt;&#x2F;p&gt;
&lt;p&gt;And of course, you&#x27;re free to fork this action and edit it with your own customizations, if you need. The exact same
flow that GitHub already allows for regular open-source work, now applied to their own CI.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ok-what-s-the-catch&quot;&gt;Ok, what&#x27;s the catch?&lt;a class=&quot;zola-anchor&quot; href=&quot;#ok-what-s-the-catch&quot; aria-label=&quot;Anchor link for: ok-what-s-the-catch&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As you may be able to tell, I like GitHub Actions quite a lot. They&#x27;re not without their shortcomings though.&lt;&#x2F;p&gt;
&lt;p&gt;I have 2 major concerns:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Still a new kid in the block&lt;&#x2F;strong&gt;. Public beta opened less than a year ago, which might be good enough of a reason to
think twice before jumping into the hype-train. It&#x27;s still in it&#x27;s infancy and, as such, a lot of things may not be
as polished as you&#x27;d expect. There&#x27;s quite a lot of missing features being requested by the community, and hopefully
we&#x27;ll see them implemented soon enough.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No SSH access for debugging&lt;&#x2F;strong&gt;. This might fall under the previous point, but the lack of ability to debug failed
actions by SSH&#x27;ing into the container was almost a deal breaker for me. I spent countless hours debugging things via
trial-and-error that would have been way faster had I just been able to see what happened for myself.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;a class=&quot;zola-anchor&quot; href=&quot;#wrapping-up&quot; aria-label=&quot;Anchor link for: wrapping-up&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;These drawbacks, as concerning as they may have been, didn&#x27;t prevent me from using GitHub Actions over the past few
months, and even performing a company-wide migration at &lt;a href=&quot;https:&#x2F;&#x2F;utrust.com&quot;&gt;Utrust&lt;&#x2F;a&gt;. This post was my way of compiling a short
tutorial around how I started using them, and how they&#x27;re so much different than previous CIs I&#x27;ve tried. By far, the
ease with each I&#x27;m able to create reusable, encapsulated actions, and the ability to react not just to commits, but to
any other event GitHub emits, is a very powerful tool.&lt;&#x2F;p&gt;
&lt;p&gt;Let me know on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;naps62&quot;&gt;twitter&lt;&#x2F;a&gt; if you have any thoughts about this!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Typespecs and Behaviours in Elixir</title>
        <published>2019-10-15T00:00:00+00:00</published>
        <updated>2019-10-15T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/typespecs-and-behaviours-in-elixir/" type="text/html"/>
        <id>https://naps62.com/posts/typespecs-and-behaviours-in-elixir/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2019&#x2F;10&#x2F;15&#x2F;behaviours.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Today2, we will dive into Typespecs and Behaviours. These are two Elixir features that we are ecstatic (pun intended) about. They are great examples of built-in features in Elixir that help get some of the advantages of statically typed code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dynamically-typed-with-features&quot;&gt;Dynamically Typed with Features&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamically-typed-with-features&quot; aria-label=&quot;Anchor link for: dynamically-typed-with-features&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Alright, letâ€™s set the scene. Elixir is a dynamically typed language. This means that the type of each variable is not checked at compile-time, but rather at run-time. Like most things, this comes with advantages and disadvantages.&lt;&#x2F;p&gt;
&lt;p&gt;The differences between statically and dynamically typed languages are sometimes the cause of heated debate, and thereâ€™s already a lot of material out there. &lt;a href=&quot;https:&#x2F;&#x2F;android.jlelse.eu&#x2F;magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b&quot;&gt;This post&lt;&#x2F;a&gt; provides a good comparison, and &lt;a href=&quot;https:&#x2F;&#x2F;blog.steveklabnik.com&#x2F;posts&#x2F;2010-07-17-what-to-know-before-debating-type-systems&quot;&gt;Chris Smithâ€™s article&lt;&#x2F;a&gt; is also a great dive into some of the fallacies that come when discussing type systems.&lt;&#x2F;p&gt;
&lt;p&gt;Despite being dynamically-typed, Elixir does a pretty good job of providing some opt-in features to get some of the safety of statically typed languages. This is important because those features often provide important guarantees about your code. This is usually done by performing static analysis on your code and, with the help of the type system, catch mistakes early on.&lt;&#x2F;p&gt;
&lt;p&gt;The two main examples of this are Typespecs and Behaviours.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;typespecs&quot;&gt;Typespecs&lt;a class=&quot;zola-anchor&quot; href=&quot;#typespecs&quot; aria-label=&quot;Anchor link for: typespecs&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;typespecs.html&quot;&gt;Typespecs&lt;&#x2F;a&gt; is an opt-in feature of Elixir that lets you annotate your functions to provide hints to the language as to what your function headers should look like. Like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Foo do
  @spec bar(arg :: binary) :: number
  def bar(arg) do
    String.length(arg)
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;@spec&lt;&#x2F;code&gt; keyword lets you specify what the argument names and types should be, as well as the return type.&lt;&#x2F;p&gt;
&lt;p&gt;This doesnâ€™t cause any kind of compilation failure if the types donâ€™t match (again, Elixir is dynamically typed, so the types arenâ€™t actually enforced at compile-time). But it has two other main benefits:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It allows for other tools to be built, which will perform static analysis on the code, and use these annotations to inform you if something looks wrong. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jeremyjh&#x2F;dialyxir&quot;&gt;dialyxir&lt;&#x2F;a&gt; is a popular tool for this;&lt;&#x2F;li&gt;
&lt;li&gt;It serves as documentation so that anyone looking at your public API can clearly see what to expect.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Elixir provides a set of basic types that you can use in these specifications. &lt;code&gt;binary&lt;&#x2F;code&gt;, &lt;code&gt;pid&lt;&#x2F;code&gt; and &lt;code&gt;number&lt;&#x2F;code&gt; are some of them (check the &lt;a href=&quot;https:&#x2F;&#x2F;elixir-lang.org&#x2F;getting-started&#x2F;basic-types.html&quot;&gt;official docs&lt;&#x2F;a&gt; for more on this). But it also allows you to compose these basic types into more complex, custom ones, using the &lt;code&gt;@type&lt;&#x2F;code&gt; directive:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;behaviours&quot;&gt;Behaviours&lt;a class=&quot;zola-anchor&quot; href=&quot;#behaviours&quot; aria-label=&quot;Anchor link for: behaviours&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Alright, now we take it to the next level and discuss behaviours. You can think of Behaviours as a kind of interface specification, like what you usually get in object-oriented languages.&lt;&#x2F;p&gt;
&lt;p&gt;Behaviours allow you to specify a contract for your modules and force them to respond to a specific API. This allows you to decouple features, using adapter patterns and other such programming techniques to piece together your code.&lt;&#x2F;p&gt;
&lt;p&gt;The upper layers of an application donâ€™t really need to care if data is persisted into PostgreSQL, MongoDB, or some other database. Thatâ€™s because Ecto provides a common language (API) to interact with adapters for these storage backends.&lt;&#x2F;p&gt;
&lt;p&gt;A behaviour specifies a list of function headers, here called callbacks. Any other Elixir module which claims to implement said behaviour will have to define those callbacks and their implementation. If one is missing, a compiler warning will be issued, letting the programmer know somethingâ€™s wrong.&lt;&#x2F;p&gt;
&lt;p&gt;An example behaviour might look something like this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;defmodule MyApp.Language do
  @callback greet(name :: binary) :: binary
  @callback thank :: binary
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This behaviour defines two function headers. These are defined just like you would a typespec, except that &lt;code&gt;@callback&lt;&#x2F;code&gt; is used, instead of &lt;code&gt;@spec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can write some implementations of our language behaviour:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;defmodule MyApp.English do
  def greet(name), do: &amp;quot;Hello, #{name}&amp;quot;
  def thank, do: &amp;quot;Thank you&amp;quot;
end

defmodule MyApp.Portuguese do
  def greet(_name), do: &amp;quot;TODO&amp;quot;
  def thank, do: &amp;quot;Obrigado&amp;quot;
end

defmodule MyApp.Japanese do
  def greet, do: &amp;quot;TODO&amp;quot;
  def thank, do: &amp;quot;TODO&amp;quot;
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This last implementation will throw a warning because weâ€™re failing to fulfill the contract. &lt;code&gt;greet&lt;&#x2F;code&gt; should actually take an argument. And even if we donâ€™t use it, we still need to expect it. &lt;code&gt;greet&#x2F;0&lt;&#x2F;code&gt; and &lt;code&gt;greet&#x2F;1&lt;&#x2F;code&gt; would be two different functions in Elixir, and the behaviour expects the latter.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;warning: function greet&amp;#x2F;1 required by behaviour MyApp.Language is not implemented (in module MyApp.Japanese)
  test.ex:20
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that this is not a compilation failure, just a warning. These annotations are only meant to guide your development and warn you of &lt;em&gt;potential&lt;&#x2F;em&gt; mistakes. Itâ€™s up to you to know what to do with them.&lt;&#x2F;p&gt;
&lt;p&gt;But before looking into a real-life example of this, we need to discuss a pattern that is commonly associated with behaviours and interfacesâ€¦&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-adapter-pattern&quot;&gt;The Adapter Pattern&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-adapter-pattern&quot; aria-label=&quot;Anchor link for: the-adapter-pattern&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The Adapter pattern is a well-known software development pattern, described in detail by the &lt;a href=&quot;https:&#x2F;&#x2F;www.goodreads.com&#x2F;book&#x2F;show&#x2F;85009.Design_Patterns&quot;&gt;Gang of Fourâ€™s book on the subject&lt;&#x2F;a&gt;. In short, itâ€™s about building public interfaces within your code, such that pieces can be swapped with other functionally-equivalent pieces while keeping everything compatible.&lt;&#x2F;p&gt;
&lt;p&gt;There are two main benefits to this:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It promotes decoupling. By enforcing that modules only talk with other modules via the specified interfaces, it doesnâ€™t matter what the underlying implementation is. As long as that part remains stable, inner refactors of your code can be made with a lot more confidence that compatibility wonâ€™t be broken&lt;&#x2F;li&gt;
&lt;li&gt;It makes it easy to switch between multiple options. Ecto, as mentioned above, is a great example of this. While writing queries with it, you donâ€™t really care if your backend is PostgreSQL, MongoDB, or something else. Ectoâ€™s query language remains the same, and each adapter takes care of translating that to its own language.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;As you may guess by now, the go-to way of creating adapters in Elixir is by using behaviours.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-example-project&quot;&gt;An Example Project&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-example-project&quot; aria-label=&quot;Anchor link for: an-example-project&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To demonstrate the usefulness of behaviours, Iâ€™ll take advantage of a real project for which I contributed.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;fun_with_flags&lt;&#x2F;code&gt; is an awesome Elixir library for dealing with feature flags. Itâ€™s also one of the better-named projects out there&lt;&#x2F;p&gt;
&lt;p&gt;Within my projects, I often felt the need to make feature flags known to my unit tests. Perhaps Iâ€™m writing tests to a disabled feature that hasnâ€™t gone live yet, and therefore need to enable it in those tests, to trigger the correct code paths. Or perhaps I want to test how the program responds to different flag values (e.g.: rolling releases).&lt;&#x2F;p&gt;
&lt;p&gt;Either way, I want the ability to enable&#x2F;disable flags in tests. But the two existing adapters pose limitations to this. Spinning a Redis instance for my test suite seems too much. And using PostgreSQL would require setting up Ecto Sandbox, and giving up on &lt;code&gt;async: true&lt;&#x2F;code&gt; completely for any related tests.&lt;&#x2F;p&gt;
&lt;p&gt;The ideal scenario was to have all this run in memory. Which we can, thanks to the adapter pattern that was chosen.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-inmemory-adapter&quot;&gt;An InMemory Adapter&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-inmemory-adapter&quot; aria-label=&quot;Anchor link for: an-inmemory-adapter&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;And here we go. Everything folded together.&lt;&#x2F;p&gt;
&lt;p&gt;The bulk of the work is to create a module that implements the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tompave&#x2F;fun_with_flags&#x2F;blob&#x2F;67025a436e64795d78183024dc68e5022cd490ff&#x2F;lib&#x2F;fun_with_flags&#x2F;store&#x2F;persistent.ex&quot;&gt;&lt;code&gt;FunWithFlags.Store.Persistent&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; behaviour. All functions listed in the behaviour (&lt;code&gt;worker_spec&#x2F;0&lt;&#x2F;code&gt;, &lt;code&gt;get&#x2F;1&lt;&#x2F;code&gt;, &lt;code&gt;put&#x2F;1&lt;&#x2F;code&gt;, &lt;code&gt;delete&#x2F;1&lt;&#x2F;code&gt;, &lt;code&gt;all_flags&#x2F;0&lt;&#x2F;code&gt; and &lt;code&gt;all_flag_names&#x2F;1&lt;&#x2F;code&gt;) need to be implemented in our adapter.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule FunWithFlags.Store.Persistent.InMemory do
  @behaviour FunWithFlags.Store.Persistent
  # ...

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: opts: __MODULE__)
  end

  def init(_), do: {:ok, []}

  def get(flag_name) do
    GenServer.call(__MODULE__, {:get, flag_name})
  end

  def put(flag_name, gate) do
    GenServer.call(__MODULE__, {:put, flag_name, gate})
  end

  # ...

  def handle_call({:get, flag_name}, _from, state) do
    # ...
    # search for the given flag in the state, and return it&amp;#x27;s status
  end

  def handle_call({:put, flag_name, gate}, _from, state) do
    # ...
    # insert the given gate into the current state
  end

  # ...
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This part of the implementation shows how the &lt;code&gt;get&#x2F;1&lt;&#x2F;code&gt; and &lt;code&gt;put&#x2F;1&lt;&#x2F;code&gt; functions are hooked up. The module is a GenServer to allow it to store and retrieve data without having to persist it to a database.&lt;&#x2F;p&gt;
&lt;p&gt;Note that I avoided displaying the actual implementation of the various &lt;code&gt;handle_call&#x2F;3&lt;&#x2F;code&gt; functions because theyâ€™re rather bulky and already beside the point of this post. But the good news is, this is actually published as a hex package, and you can check it out on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;fun_with_flags_in_memory&quot;&gt;Github&lt;&#x2F;a&gt; too!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now weâ€™ve gone all the way into the rabbit hole of this post, from theory to practice. From TypeSpecs, and how behaviours are a cool implementation of Adapter patterns in Elixir to the real-life example. We even got out at the other end on our best behaviour ;-)&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Routing in Phoenix Umbrella Apps</title>
        <published>2019-04-16T00:00:00+00:00</published>
        <updated>2019-04-16T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/routing-in-phoenix-umbrella-apps/" type="text/html"/>
        <id>https://naps62.com/posts/routing-in-phoenix-umbrella-apps/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2019&#x2F;04&#x2F;16&#x2F;elixir-alchemy-routing-phoenix-umbrella-apps.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;elixirschool.com&#x2F;en&#x2F;lessons&#x2F;advanced&#x2F;umbrella-projects&#x2F;&quot;&gt;Umbrella apps&lt;&#x2F;a&gt; are an awesome way to structure Elixir projects.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the curtains, they are a very thin layer that just compiles everything to a single package. Instead of building a single large monolith, you can structure your code with multiple isolated contexts. They all get compiled and run under the same BEAM instance, so they still have access to each other. Meanwhile the conceptual separation ensures you have separate OTP apps for each of your umbrella children. And it allows you to work on each of them with a certain degree of isolation.&lt;&#x2F;p&gt;
&lt;p&gt;Think of this as a poor manâ€™s microservices solution. You donâ€™t need to add a messaging queue or send HTTP requests between each service since theyâ€™re all actually running under the same process, but you still get some of the benefits.&lt;&#x2F;p&gt;
&lt;p&gt;If you want to know more about umbrella applications, I suggest the &lt;a href=&quot;https:&#x2F;&#x2F;elixir-lang.org&#x2F;getting-started&#x2F;mix-otp&#x2F;dependencies-and-umbrella-projects.html#umbrella-projects&quot;&gt;official guide&lt;&#x2F;a&gt; as a starter, as it clearly outlines the advantages and caveats of umbrella apps.&lt;&#x2F;p&gt;
&lt;p&gt;Now letâ€™s look at a real life example where Iâ€™ve implemented an umbrella app.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-real-example&quot;&gt;A Real Example&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-real-example&quot; aria-label=&quot;Anchor link for: a-real-example&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Letâ€™s say Iâ€™m building a website for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Magic:_The_Gathering&quot;&gt;Magic: The Gathering (MTG)&lt;&#x2F;a&gt; cards. Whichâ€¦ well, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;mse&quot;&gt;I am&lt;&#x2F;a&gt;. The idea is to create an interface where users can browse and search a database of cards. Thereâ€™s also an admin panel where some administrative tasks can be performed.&lt;&#x2F;p&gt;
&lt;p&gt;Clearly, each of these frontend interfaces has different requirements:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The main frontend is public while the admin side only has private access.&lt;&#x2F;li&gt;
&lt;li&gt;The admin panel may even have its own UI requirements. In this case, Iâ€™m using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smpallen99&#x2F;ex_admin&quot;&gt;ex_admin&lt;&#x2F;a&gt; for convenience. This means, even UI assets are not shared.&lt;&#x2F;li&gt;
&lt;li&gt;They mostly have completely different back-end logic as well. Only a small subset of the queries and operations can be shared between the two.&lt;&#x2F;li&gt;
&lt;li&gt;I may also want to access both of them through different URLs (e.g. use an &lt;code&gt;admin&lt;&#x2F;code&gt; subdomain for the Admin frontend).
The multiple differences between the two make it clear that it would be better for these to be two separate phoenix appsâ€”each with its own setup.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Something like this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;apps&amp;#x2F;
  client&amp;#x2F;
  admin&amp;#x2F;
  shared&amp;#x2F;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;looks-easy-enough-what-s-the-issue&quot;&gt;Looks Easy Enough. Whatâ€™s the Issue?&lt;a class=&quot;zola-anchor&quot; href=&quot;#looks-easy-enough-what-s-the-issue&quot; aria-label=&quot;Anchor link for: looks-easy-enough-what-s-the-issue&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The problem comes when you try to figure out how to actually implement this. How do you route requests from the &lt;code&gt;admin&lt;&#x2F;code&gt; subdomain to another Phoenix app while routing other requests to the main Phoenix app?&lt;&#x2F;p&gt;
&lt;p&gt;One solution would be to run each of those apps on a different port. But then, youâ€™ll either be left accessing &lt;code&gt;admin.mydomain.com:4001&lt;&#x2F;code&gt;, or youâ€™ll need some other middle layer to abstract away that port distinction from your browser. While this may be fine for an admin page that only you will access, it doesnâ€™t work as well for a general solution.&lt;&#x2F;p&gt;
&lt;p&gt;The old school solution is to put a reverse proxy between your clients and your server. nginx does this job pretty well. But in reality, you know all this is a single Elixir application. It seems weird to need a third party server to be able to route requests to different parts of it.&lt;&#x2F;p&gt;
&lt;p&gt;It also doesnâ€™t solve the problem of local development, unless you want to run nginx locally as well, which is less than ideal.&lt;&#x2F;p&gt;
&lt;p&gt;Weâ€™re Elixir developers after all, and weâ€™re pretty smart. So letâ€™s do this the Elixir way:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introducing-a-proxy-app&quot;&gt;Introducing a Proxy App&lt;a class=&quot;zola-anchor&quot; href=&quot;#introducing-a-proxy-app&quot; aria-label=&quot;Anchor link for: introducing-a-proxy-app&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The solution I came up with (i.e. read suggestions from similar use cases on Stack Overflow) was to create an additional umbrella child, which will be the main point of contact to the outside world.&lt;&#x2F;p&gt;
&lt;p&gt;This app, which weâ€™ll call &lt;code&gt;proxy&lt;&#x2F;code&gt;, will receive all incoming HTTP requests and forward them to the appropriate Phoenix app, based on a few simples rules. In our simple use case, requests to &lt;code&gt;admin.mydomain.com&lt;&#x2F;code&gt; will be forwarded to the &lt;code&gt;admin&lt;&#x2F;code&gt; app, and all others will be forwarded to the &lt;code&gt;client&lt;&#x2F;code&gt; app.&lt;&#x2F;p&gt;
&lt;p&gt;This is a very simple phoenix app, which you can generate with &lt;code&gt;mix phx.new&lt;&#x2F;code&gt; like all the others. Dependencies will be kept to a minimum here. We only have phoenix &amp;amp; cowboy as external dependencies (to set up our web server), as well as the client and admin apps to which weâ€™ll be forwarding requests:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;def deps do
  [
    {:client, in_umbrella: true},
    {:admin, in_umbrella: true},
    {:phoenix, &amp;quot;~&amp;gt; 1.3.2&amp;quot;},
    {:cowboy, &amp;quot;~&amp;gt; 1.0&amp;quot;}
  ]
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since this app will be the actual web server, we should disable the server setting in the other two:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;# apps&amp;#x2F;client&amp;#x2F;config&amp;#x2F;config.exs
config :client, Client.Web.Endpoint, server: false

# apps&amp;#x2F;admin&amp;#x2F;config&amp;#x2F;config.exs
config :admin, Admin.Web.Endpoint, server: false

# apps&amp;#x2F;proxy&amp;#x2F;config&amp;#x2F;config.exs
config :proxy, Proxy.Endpoint, server: true
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This ensures that only the proxy app will be listening to a port. This is not mandatory but it saves you the trouble of having to define different ports for each one (remember: only one listener per port is allowed) and ensures all requests actually go through the proxy appâ€”which is indeed the expected behavior.&lt;&#x2F;p&gt;
&lt;p&gt;Leaving &lt;code&gt;server: true&lt;&#x2F;code&gt; might be useful in development or testing mode, depending on how you want to set up your environment.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;setting-up-the-endpoint&quot;&gt;Setting up the Endpoint&lt;a class=&quot;zola-anchor&quot; href=&quot;#setting-up-the-endpoint&quot; aria-label=&quot;Anchor link for: setting-up-the-endpoint&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The entry point of a Phoenix app is the Endpoint module. In this case, weâ€™ve set this to Proxy.Endpoint. Since this app really has no other responsibility, thereâ€™s no need to nest it under the Web module, as is common practice in Phoenix.&lt;&#x2F;p&gt;
&lt;p&gt;However, we can strip down most things from the Endpoint module created for us by the Phoenix generator and end up with a very simple module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Proxy.Endpoint do
  use Phoenix.Endpoint, otp_app: :proxy

  @base_host_regex ~r|\.?mydomain.*$|
  @subdomains %{
    &amp;quot;admin&amp;quot; =&amp;gt; Admin.Web.Endpoint,
    &amp;quot;client&amp;quot; =&amp;gt; Client.Web.Endpoint
  }
  @default_host Client.Web.Endpoint

  def init(opts), do: opts

  def call(conn, _) do
    with subdomain &amp;lt;- String.replace(host, @base_host_regex, &amp;quot;&amp;quot;),
         endpoint &amp;lt;- Map.get(@subdomains, subdomain, @default_host) do
      endpoint.call(conn, endpoint.init())
    end
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Letâ€™s go over this one step at a time:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;@base_host_regex ~r|\.?mydomain.*$|
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is used to extract the subdomain part of the host URL of every request. So for &lt;code&gt;admin.mydomain.com&lt;&#x2F;code&gt; we want to get the string &lt;code&gt;admin&lt;&#x2F;code&gt; and for &lt;code&gt;mydomain.com&lt;&#x2F;code&gt; we will end up with an empty string (meaning, weâ€™ll forward this to the default app. More on that later).&lt;&#x2F;p&gt;
&lt;p&gt;Notice that this doesnâ€™t exactly match the &lt;code&gt;.com&lt;&#x2F;code&gt; part. This is a convenience change I made for local development. Matching on &lt;code&gt;mydomain.*&lt;&#x2F;code&gt; allows me to use &lt;code&gt;admin.mydomain.lvh.me&lt;&#x2F;code&gt; when working on my local machine, and still have this whole logic working without making development-specific changes.&lt;&#x2F;p&gt;
&lt;p&gt;If you donâ€™t know what &lt;code&gt;lvh.me&lt;&#x2F;code&gt; is, &lt;a href=&quot;https:&#x2F;&#x2F;nickjanetakis.com&#x2F;blog&#x2F;ngrok-lvhme-nipio-a-trilogy-for-local-development-and-testing#lvh-me&quot;&gt;this article&lt;&#x2F;a&gt; might be helpful (TL;DR: Itâ€™s a development service that resolves its name to &lt;code&gt;localhost&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;With the above regex in mind, the next part should be easy to understand:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;@subdomains %{
    &amp;quot;admin&amp;quot; =&amp;gt; Admin.Web.Endpoint,
    &amp;quot;client&amp;quot; =&amp;gt; Client.Web.Endpoint
}
@default_host Client.Web.Endpoint
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For every subdomain, we want to match a particular Phoenix endpoint belonging to the app that we want to forward the request to. @default_host is what weâ€™ll use if the subdomain is missing (the empty string scenario we talked above).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;def call(conn, _) do
    with subdomain &amp;lt;- String.replace(host, @base_host_regex, &amp;quot;&amp;quot;),
         endpoint &amp;lt;- Map.get(@subdomains, subdomain, @default_host) do
      endpoint.call(conn, endpoint.init())
    end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When this endpointâ€”which is actually not much more than an &lt;a href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;plug&#x2F;readme.html&quot;&gt;Elixir Plug&lt;&#x2F;a&gt;â€”is called, we just grab the subdomain from the request host, then find the matching endpoint from our mapping (defaulting to &lt;code&gt;@default_host&lt;&#x2F;code&gt;), and call &lt;code&gt;endpoint.call&#x2F;2&lt;&#x2F;code&gt; on it. This is essentially delegating the call down to the appropriate app.&lt;&#x2F;p&gt;
&lt;p&gt;Now &lt;code&gt;client&lt;&#x2F;code&gt; and &lt;code&gt;admin&lt;&#x2F;code&gt; both have to only worry about their corresponding requests and authentication. All logic related to the multiple subdomains &amp;amp; clients we may need is abstracted away in this app.&lt;&#x2F;p&gt;
&lt;p&gt;Want a new client in the same umbrella? Add it here! Want the same endpoint to respond to additional subdomains? Add it here!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;taking-the-routing-even-further&quot;&gt;Taking the routing even further&lt;a class=&quot;zola-anchor&quot; href=&quot;#taking-the-routing-even-further&quot; aria-label=&quot;Anchor link for: taking-the-routing-even-further&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;By adding a smart router to our umbrella application, weâ€™re now able to serve requests to different subdomains to different apps in our umbrella application. I first implemented this pattern on a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;mse&#x2F;tree&#x2F;master&#x2F;apps&#x2F;proxy&quot;&gt;pet project of mine&lt;&#x2F;a&gt;, but have since used and improved it on a few production projects as well.&lt;&#x2F;p&gt;
&lt;p&gt;We could take this much further. For example, if youâ€™re migrating an existing service from Ruby to Elixir. You can have this proxy application route all requests made to the Ruby version of your service redirected back to the Ruby application, ensuring backward-compatibility. Or you may want the opposite scenario, where youâ€™re creating a new API service and want to forward matching requests to a different client or even to a different web server altogether.&lt;&#x2F;p&gt;
&lt;p&gt;We can also take the routing complexity to another level. Routing was done here based solely on the subdomain of the request. But depending on your needs, you can create more complex routing rules using HTTP headers or query parameters. All of this can be done while keeping your actual web services completely oblivious to it.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Flags, Seeds and Idempotency: Database Tooling with Elixir</title>
        <published>2019-02-19T00:00:00+00:00</published>
        <updated>2019-02-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/flags-seeds-and-idempotency-elixir/" type="text/html"/>
        <id>https://naps62.com/posts/flags-seeds-and-idempotency-elixir/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2019&#x2F;09&#x2F;10&#x2F;flags-seeds-idempotency-elixir.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Today we stir into our cauldron of magic potions and idempotence, and brew some neat Elixir database tooling. Weâ€™ll do so by going through my experience of setting up my own.&lt;&#x2F;p&gt;
&lt;p&gt;Coming from Ruby on Rails, one of the things that Iâ€™ve seen lacking in the Elixir space when it comes to web applications is the helpful tooling that existed in the ecosystem to deal with databases in production. In this post, weâ€™ll cover some of these and see how we can create similar tools in Elixir.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;customizing-the-workflow-when-setting-up-a-database&quot;&gt;Customizing the Workflow When Setting up a Database&lt;a class=&quot;zola-anchor&quot; href=&quot;#customizing-the-workflow-when-setting-up-a-database&quot; aria-label=&quot;Anchor link for: customizing-the-workflow-when-setting-up-a-database&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Most deployment solutions for Ruby on Rails would handle the setup of the database, tying directly into the way they are configured in the framework. This often included such things as:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Creating and setting up the initial database&lt;&#x2F;li&gt;
&lt;li&gt;Running all existing migrations&lt;&#x2F;li&gt;
&lt;li&gt;Seeding the database&lt;&#x2F;li&gt;
&lt;li&gt;Continuously running new migrations as they get added in future releases&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This was all part of the ecosystem and was often taken for granted. But actually, thereâ€™s a lot of work involved in plugging all those things together. And sometimes, assumptions were made that made it difficult to tweak this flow to your particular needs.&lt;&#x2F;p&gt;
&lt;p&gt;What if you have some kind of horizontal scaling on your application and need a more custom way to decide when and how migrations are executed? Or simply, what if you want to customize the order or the way each of these steps is done?&lt;&#x2F;p&gt;
&lt;p&gt;The Ruby way of convention-over-configuration is pretty cool, especially when it comes to being a friendly environment for newcomers. But sometimes, the Elixir approach of explicitness has its benefits as well.&lt;&#x2F;p&gt;
&lt;p&gt;With my latest projects, I ended up with some behavior where the ability to fully customize this workflow came in very handy. This ended up in a way that ensures our database is always in a ready state across deploys and even across database resets. Letâ€™s dive into what we did and learned!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;running-migrations&quot;&gt;Running Migrations&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-migrations&quot; aria-label=&quot;Anchor link for: running-migrations&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As an introduction, letâ€™s first see how migrations can be executed on Elixir. Iâ€™ll be using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;distillery&quot;&gt;distillery releases&lt;&#x2F;a&gt; to showcase this, but the process is pretty much translatable to any other Elixir&#x2F;Erlang system.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule MyApp.Migrator do
def run do
{:ok, _} = Application.ensure_all_started(:my_app)

path = Application.app_dir(:my_app, &amp;quot;priv&amp;#x2F;repo&amp;#x2F;migrations&amp;quot;)

Ecto.Migrator.run(MyApp.Repo, path, :up, all: true)
  end
  end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above module provides a function that executes migrations for a particular Repo in our application. Right from the start, we notice that all of this is very easily customizable since itâ€™s pure Elixir code that we can change ourselves. Do you have two repos with different migration directories for each? Do you have an umbrella app with several repos spread across it? All of that can be handled here, according to your applicationâ€™s needs.&lt;&#x2F;p&gt;
&lt;p&gt;The above function is pretty much the equivalent of &lt;code&gt;mix ecto.migrate&lt;&#x2F;code&gt;. But mix tasks arenâ€™t available in Elixir releases, which is why we end up having to write them ourselves.&lt;&#x2F;p&gt;
&lt;p&gt;To run this within our release, we can run this script as a start hook:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;# rel&amp;#x2F;pre_start_hooks&amp;#x2F;10_migrate.sh

$RELEASE_ROOT_DIR&amp;#x2F;bin&amp;#x2F;my_app command Elixir.MyApp.Migrator run


# rel&amp;#x2F;config.exs

# ...

release :my_app do
 # ...

 set(pre_start_hooks: &amp;quot;rel&amp;#x2F;pre_start_hooks&amp;quot;)

 set(
   commands: [
     migrate: &amp;quot;rel&amp;#x2F;pre_start_hooks&amp;#x2F;10_migrate.sh&amp;quot;
   ]
 )
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These two additions to our Distillery setup will ensure that the migration function is called every time the application starts (which means, every time we deploy a new version). So migrations will end up running automatically as theyâ€™re deployed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;seeding-your-database&quot;&gt;Seeding Your Database&lt;a class=&quot;zola-anchor&quot; href=&quot;#seeding-your-database&quot; aria-label=&quot;Anchor link for: seeding-your-database&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have played around with migrations, letâ€™s look into seeding your database. Usually, &lt;code&gt;mix seed&lt;&#x2F;code&gt; will be used to insert initial records in your database. These are the records your app needs to function properly before your users get to it.&lt;&#x2F;p&gt;
&lt;p&gt;This task just runs an Elixir script stored in &lt;code&gt;priv&#x2F;repo&#x2F;seeds.exs&lt;&#x2F;code&gt;. But as weâ€™ve seen, Mix tasks are not available within a release.&lt;&#x2F;p&gt;
&lt;p&gt;Usually, your seeds file will consist of something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;[&amp;quot;user&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;editor&amp;quot;]
|&amp;gt; Enum.each(fn role -&amp;gt;
  MyApp.Role.new(name: role)
  |&amp;gt; MyApp.Repo.insert()
end)

MyApp.User.new(name: &amp;quot;Admin&amp;quot;, role: &amp;quot;admin&amp;quot;)
|&amp;gt; MyApp.Repo.insert()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To set this up within Distillery, I moved this logic into its own compiled module rather than an .exs script:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule MyApp.Seeds do
  def run do
    [&amp;quot;user&amp;quot;, &amp;quot;admin&amp;quot;, &amp;quot;editor&amp;quot;]
    |&amp;gt; Enum.each(fn role -&amp;gt;
      MyApp.Role.new(name: role)
      |&amp;gt; MyApp.Repo.insert()
    end)

    MyApp.User.new(name: &amp;quot;Admin&amp;quot;, role: &amp;quot;admin&amp;quot;)
    |&amp;gt; MyApp.Repo.insert()
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;priv&#x2F;repo&#x2F;seeds.exs&lt;&#x2F;code&gt; script still exists, but it just calls the newly created function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;# priv&amp;#x2F;repo&amp;#x2F;seeds.exs

MyApp.Seeds.run()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This way, weâ€™re ready to set it up as a Distillery pre-start hook.&lt;&#x2F;p&gt;
&lt;p&gt;This is usually fine for local development, but if youâ€™re setting this up as a pre-start hook, it means this script will be executed over and over again, after each new deploy. If youâ€™re not careful, you may end up inserting duplicate seed data each time.&lt;&#x2F;p&gt;
&lt;p&gt;One could solve this with some tricks that try and check if seeds were already run (such as setting a flag somewhere in the database and checking for it). But thereâ€™s a much more powerful way: Idempotent seeds.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;idempotent-seeds&quot;&gt;Idempotent Seeds&lt;a class=&quot;zola-anchor&quot; href=&quot;#idempotent-seeds&quot; aria-label=&quot;Anchor link for: idempotent-seeds&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Letâ€™s get to the coolest stuff!&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Idempotence&lt;&#x2F;strong&gt; is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;In short, an idempotent operation is one that you can harmlessly run multiple times, without fear of ending up with duplicate or accumulated results. For database seeds, ensuring their idempotency means you donâ€™t need to worry about ending up with multiple admin users, for example.&lt;&#x2F;p&gt;
&lt;p&gt;As it turns out, another very useful feature of moving seeds logic into a compiled module is the ability to unit-test them! Which is what I did:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule MyApp.SeedsTest do
  use MyApp.DataCase, async: false

  test &amp;quot;creates an admin user&amp;quot; do
    MyApp.Seeds.run()

    assert admin = MyApp.Repo.one(MyApp.User)
    assert admin.role == &amp;quot;admin&amp;quot;
  end

  test &amp;quot;admin user creation is idempotent&amp;quot; do
    MyApp.Seeds.run()
    MyApp.Seeds.run()

    user_count = MyApp.Repo.aggregate(MyApp.User, :count, :id)
    assert user_count == 1
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first test ensures the seed does what itâ€™s supposed to (in this case, the simple creation of a role in the database). The second one ensures that running the seeds twice doesnâ€™t affect the final result.&lt;&#x2F;p&gt;
&lt;p&gt;In a complex system where your codebase is constantly evolving, and the rest of your team is building features on top of other features, itâ€™s common for someone to accidentally add changes that donâ€™t behave as expected once they go live. Itâ€™s easy for a developer on your team to add a few new seeds, forgetting how that will play out in production. Letâ€™s see a more practical example of this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;seeding-feature-flags&quot;&gt;Seeding Feature Flags&lt;a class=&quot;zola-anchor&quot; href=&quot;#seeding-feature-flags&quot; aria-label=&quot;Anchor link for: seeding-feature-flags&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;One feature we rely a lot on is feature flags, which give us the ability to toggle behavior on and off without requiring a new release. In Elixir, I do this using the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tompave&#x2F;fun_with_flags&quot;&gt;FunWithFlags package&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When a new flag is being added to the codebase, its initial value may not be too trivial to introduce. Are we adding a new feature, and therefore the flag should start out as &lt;code&gt;false&lt;&#x2F;code&gt;? Or are we wrapping an existing feature around a flag, so that we can later remove or change it, in which case the flag should be &lt;code&gt;true&lt;&#x2F;code&gt; by default, so as to preserve behavior?&lt;&#x2F;p&gt;
&lt;p&gt;This may even change between environments. We may want certain flags to be enabled by default on our staging system but disabled in production until we manually enable them.&lt;&#x2F;p&gt;
&lt;p&gt;This requirement ties in nicely with our ability to run seeds for our application in an idempotent way, check it out:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule MyApp.FlagsSeeds do
  def run do
    set_flag_if_not_set(:new_disabled_feature, false)
    if System.get_env(&amp;quot;ENV_NAME&amp;quot;) == &amp;quot;staging&amp;quot; do
      set_flag_if_not_set(:new_staging_feature, true)
    else
      set_flag_if_not_set(:new_staging_feature, false)
    end
  end

  defp set_flag_if_not_set(flag_name, value) do
    {:ok, existing} = FunWithFlags.all_flag_names()

    cond do
      Enum.member?(existing, flag_name) -&amp;gt;
        # flag already exists. skip operation
        nil

      value == true -&amp;gt;
        FunWithFlags.enable(flag_name)

      value == false -&amp;gt;
        FunWithFlags.disable(flag_name)

      true -&amp;gt;
        raise &amp;quot;Invalid flag value&amp;quot;
    end
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this module, weâ€™re able to programmatically define the initial value of our seeds, which can be dependent on some other factor, such as which environment weâ€™re running in.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;set_flag_if_not_set&#x2F;2&lt;&#x2F;code&gt; function is the materialization of our idempotency requirement. We wouldnâ€™t want a new release to disable a flag that we have already manually enabled, right?&lt;&#x2F;p&gt;
&lt;p&gt;By first checking if the flag already exists, we ensure two things:&lt;&#x2F;p&gt;
&lt;p&gt;This flags module is idempotent since a second run will skip all flags
It only works for unset flags, allowing us to manually set their values when needed, without fear of being overridden
We can get even fancier when testing this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule MyApp.FlagSeedsTest do
  use MyApp.DataCase, async: false

  test &amp;quot;is idempotent&amp;quot; do
    MyApp.FlagSeeds.run()
    current_flags = FunWithFlags.all_flags()

    MyApp.FlagSeeds.run()
    new_flags = FunWithFlags.all_flags()

    assert current_flags == new_flags()
  end

end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, if I or someone else on my team wrongfully change the seeds file in a way that breaks idempotency, our test suite will catch that before it even reaches a live environment, saving everyone a lot of trouble.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wave&quot;&gt;ðŸ‘‹&lt;a class=&quot;zola-anchor&quot; href=&quot;#wave&quot; aria-label=&quot;Anchor link for: wave&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I hope you enjoyed this little dive into some of the tooling we built, and that youâ€™ve picked up some things you can use yourself. ðŸ‘‹&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Metaprogramming: From C Preprocessing to Elixir Macros</title>
        <published>2019-02-19T00:00:00+00:00</published>
        <updated>2019-02-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/metaprogramming-from-c-to-elixir/" type="text/html"/>
        <id>https://naps62.com/posts/metaprogramming-from-c-to-elixir/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2019&#x2F;07&#x2F;16&#x2F;elixir-alchemy-metaprogramming.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Developers have a love-hate relationship with metaprogramming. On the one hand, itâ€™s a powerful tool to build reusable code. On the other hand, it can quickly become hard to understand and maintain.&lt;&#x2F;p&gt;
&lt;p&gt;I like to think of it as salt. Itâ€™s pretty handy on many occasions, but use just a little too much of it, and youâ€™re left with an unenjoyable dish.&lt;&#x2F;p&gt;
&lt;p&gt;Also, large doses of either of them can lead to increased blood pressure. ðŸ˜…&lt;&#x2F;p&gt;
&lt;p&gt;However, metaprogramming has come a long way since itâ€™s early days. While I still try not to overuse it, itâ€™s become more useful and easy to work with. Letâ€™s see how it evolved.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;c-c&quot;&gt;C&#x2F;C++&lt;a class=&quot;zola-anchor&quot; href=&quot;#c-c&quot; aria-label=&quot;Anchor link for: c-c&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If we go back a few decades, to a time when programming languages were more close to the metal, the C&#x2F;C++ preprocessor was one of the only options we had to do something close to metaprogramming.&lt;&#x2F;p&gt;
&lt;p&gt;This preprocessor was literally what the name suggests: A parser that would run through C code, and process specific definitions (keywords such as &lt;code&gt;#define&lt;&#x2F;code&gt; and &lt;code&gt;#if&lt;&#x2F;code&gt;), and would output a final version of the C code to the compiler. This final version could change based on some criteria. It would look something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;#define FOO 1

#if FOO == 1
#define MSG &amp;quot;Hello, World&amp;quot;
#else
#define MSG &amp;quot;Goodbye, World&amp;quot;
#endif

#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(MSG);
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This program would print &lt;code&gt;&amp;quot;Hello, World&amp;quot;&lt;&#x2F;code&gt;, always. As you may guess, changing the FOO definition to 0, and re-compiling the program, would instead cause it to print &lt;code&gt;&amp;quot;Goodbye, World&amp;quot;&lt;&#x2F;code&gt; instead.&lt;&#x2F;p&gt;
&lt;p&gt;These preprocessor directives would often be used to create code targeting specific platforms or architectures. For example, you could set different behaviors for your program when compiled to target Windows systems than when targeting Linux systems. The two resulting binaries would have only the code that was relevant to that specific platform, and thus wouldnâ€™t need to perform runtime checks for these conditions. These savings in storage and runtime performance could often be significant.&lt;&#x2F;p&gt;
&lt;p&gt;However, if you have any C experience at all, you know how dangerous it is just in vanilla form. Now add a lot of preprocessing behavior on top of that, and it quickly becomes quite hard to manage. So it wouldnâ€™t be advisable to use it for much more than small configurations, most of the time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ruby&quot;&gt;Ruby&lt;a class=&quot;zola-anchor&quot; href=&quot;#ruby&quot; aria-label=&quot;Anchor link for: ruby&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;With better technology and higher-level scripting languages, also came the possibility of creating more elaborate styles of programming. Particularly in Ruby, metaprogramming proved to be a powerful, yet scary feature.&lt;&#x2F;p&gt;
&lt;p&gt;The way this works in Ruby is based on the idea that code is nothing more than a string of text, interpreted and executed by the Ruby environment.&lt;&#x2F;p&gt;
&lt;p&gt;Since Ruby is interpreted at runtime, thereâ€™s no requirement of having the entire codebase compiled upfront. Ruby allows you to dynamically define instance methods on classes.&lt;&#x2F;p&gt;
&lt;p&gt;Also, due to the way Ruby classes and instances are constructed internally, you can even define methods for individual instances rather than the entire class!&lt;&#x2F;p&gt;
&lt;p&gt;PS: Further reading on Ruby Classes &lt;a href=&quot;https:&#x2F;&#x2F;www.devalot.com&#x2F;articles&#x2F;2008&#x2F;09&#x2F;ruby-singleton&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ruby&quot; class=&quot;language-ruby &quot;&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class Foo
  def hello1
    puts &amp;quot;Hello from a regular method&amp;quot;
  end

  [:hello2, :hello3].each do |f|
    define_method f do
      puts &amp;quot;Hello from a dynamically-defined #{f} method&amp;quot;
    end
  end
end

foo = Foo.new

foo.define_singleton_method(:hello4) { puts &amp;quot;Hello only from this instance of Foo&amp;quot; }

foo.hello1
foo.hello2
foo.hello3
foo.hello4
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ruby is also pretty lax when it comes to editing existing code, even from the standard library. This is valid Ruby:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ruby&quot; class=&quot;language-ruby &quot;&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;array = [1, 2, 3]

# will print out 3
puts array.size

class Array
  def size
    &amp;quot;Hello&amp;quot;
  end
end

# will now print out &amp;quot;Hello&amp;quot;
puts array.size
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Donâ€™t to that, though! It will most likely break your program and is a bad practice overall.&lt;&#x2F;p&gt;
&lt;p&gt;Last but not least, Ruby has some powerful ways of handling unexpected function calls, such as the &lt;code&gt;method_missing&lt;&#x2F;code&gt; callback:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ruby&quot; class=&quot;language-ruby &quot;&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;array = [1, 2, 3]

class Array
  def method_missing(method, *args)
    puts &amp;quot;#{method} method not found&amp;quot;

    if method == :sise then
      puts &amp;quot;Did you intend to type size instead?&amp;quot;
    end
  end
end

puts array.sise
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Overall, these abilities were a big game-changer for me when I first learned about them. It enabled me to think about my codebase in a whole new different way and improve it in the process.&lt;&#x2F;p&gt;
&lt;p&gt;There were some issues, though. You know what they say: with great power comes great responsibility.&lt;&#x2F;p&gt;
&lt;p&gt;Several Ruby libraries used and abused these metaprogramming mechanisms to create their own Domain Specific Languages. In the long run, this overuse would result in similar problems as we had in C++ times: difficulty maintaining and understanding a codebase.&lt;&#x2F;p&gt;
&lt;p&gt;Elixir took, in my opinion, yet another step forward in the right direction hereâ€¦&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elixir&quot;&gt;Elixir â¤ï¸&lt;a class=&quot;zola-anchor&quot; href=&quot;#elixir&quot; aria-label=&quot;Anchor link for: elixir&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Here, metaprogramming is built into the languageâ€™s core in a much more powerful way. Whereas Ruby allowed you to define methods dynamically, or event generate a string and evaluate it as code (the old &lt;code&gt;eval&lt;&#x2F;code&gt; method that we all hate), Elixir allows you to mess with the Abstract Syntax Tree (AST) itself.&lt;&#x2F;p&gt;
&lt;p&gt;This is done through the &lt;code&gt;quote&lt;&#x2F;code&gt; keyword:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; expr = quote do
  &amp;quot;Hello, &amp;quot; &amp;lt;&amp;gt; &amp;quot;World&amp;quot;
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Trying out the above code, youâ€™ll find that the string concat operation doesnâ€™t get executed directly. Instead of a final string, you end up with an AST expression that describes your code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;{:&amp;lt;&amp;gt;, [context: Elixir, import: Kernel], [&amp;quot;Hello, &amp;quot;, &amp;quot;World&amp;quot;]}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Those familiar with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Polish_notation&quot;&gt;Polish Notation&lt;&#x2F;a&gt; may quickly identify that this is equivalent to the string concatenation code from above. So by quoting some code, you get an AST description of that code, which you can then use across the rest of your codebase.&lt;&#x2F;p&gt;
&lt;p&gt;You can then start to reason about your code as if it were a data structure (which it isâ€¦ an AST), and perform operations to transform it:&lt;&#x2F;p&gt;
&lt;p&gt;Letâ€™s modify things a little bit:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; expr = quote do
  &amp;quot;Hello, &amp;quot; &amp;lt;&amp;gt; name
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now our expression uses a dynamic name instead. However, where does that name come from? We donâ€™t have that variable defined anywhere, but it is still syntactically correct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;{:&amp;lt;&amp;gt;, [context: Elixir, import: Kernel], [&amp;quot;Hello, &amp;quot;, {:name, [], Elixir}]}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, it will fail to execute, which we can test by using &lt;code&gt;Code.eval_quoted&#x2F;3&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; Code.eval_quoted(expr)
** (CompileError) nofile:1: undefined function name&amp;#x2F;0
    (elixir) lib&amp;#x2F;code.ex:590: Code.eval_quoted&amp;#x2F;3
    test.ex:5: (file)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Letâ€™s now create a second AST definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;definition = quote do
  name = &amp;quot;Miguel&amp;quot;
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This second expression definition defines a variable called &lt;code&gt;name&lt;&#x2F;code&gt;. However, remember, weâ€™re not defining any value, just creating the AST for that operation.&lt;&#x2F;p&gt;
&lt;p&gt;We can combine these two expressions into a single one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;final_code = quote do
  unquote(definition)
  unquote(expr)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This ends up having the same result as if we had typed:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;name = &amp;quot;Miguel&amp;quot;
&amp;quot;Hello, &amp;quot; &amp;lt;&amp;gt; name
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, notice we never had to abandon the Elixir syntax and rules while doing so. Weâ€™re writing Elixir that writes Elixir!&lt;&#x2F;p&gt;
&lt;p&gt;This is heavily used internally within Elixirâ€™s core. Whenever you define a function, or a simple if statement, youâ€™re executing macros that change the codeâ€™s AST according to fit your code into them. Speaking of whichâ€¦&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elixir-s-macros&quot;&gt;Elixirâ€™s Macros&lt;a class=&quot;zola-anchor&quot; href=&quot;#elixir-s-macros&quot; aria-label=&quot;Anchor link for: elixir-s-macros&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Much of Elixirâ€™s features are written with macros. Many of the common operators you use can be rewritten with macros. Letâ€™s take, for instance, the &lt;code&gt;unless&lt;&#x2F;code&gt; operator (which already exists in the languageâ€™s core) and define it ourselves:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Foo do
  defmacro custom_unless(condition, do: do_clause, else: else_clause) do quote do
      if !unquote(condition) do
        unquote(do_clause)
      else
        unquote(else_clause)
      end
    end
  end

  defmacro custom_unless(condition, do: do_clause) do
    quote do
      Foo.custom_unless(unquote(condition), do: unquote(do_clause), else: nil)
    end
  end
end

defmodule Bar do
  require Foo

  Foo.custom_unless true, do: IO.puts(&amp;quot;not true&amp;quot;), else: IO.puts(&amp;quot;true&amp;quot;)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our &lt;code&gt;custom_unless&lt;&#x2F;code&gt; macro take in a boolean value. Inside, we check for the opposite of the condition (we run whatever code AST was given on that condition, and invert the resulting boolean). Then we execute the AST given for either the &lt;code&gt;do&lt;&#x2F;code&gt; or the else clause, depending on the result.&lt;&#x2F;p&gt;
&lt;p&gt;However, the fun part about Elixir is that, since even the basic constructs such as &lt;code&gt;if&lt;&#x2F;code&gt; clauses are often built using macros themselves, we can better embed our macros in the language. In other words, after defining our macro, this is also working Elixir code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Bar
  # importing instead of requiring allows us to call the macro directly,
  # without the Foo. prefix
  import Foo

  custom_unless true do
    IO.puts(&amp;quot;not true&amp;quot;)
  else
    IO.puts(&amp;quot;true&amp;quot;)
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works because the interpretation of a multiline &lt;code&gt;if&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;else&lt;&#x2F;code&gt; block in Elixir is not much more than syntactic sugar for:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;if condition do: something, else: something_else
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Hopefully, this has been a useful walkthrough of how macros evolved in the past, especially for Elixir developers that may not know the full power of their language, as well as the history.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Pouring Protocols in Elixir</title>
        <published>2019-02-19T00:00:00+00:00</published>
        <updated>2019-02-19T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/pouring-protocols-in-elixir/" type="text/html"/>
        <id>https://naps62.com/posts/pouring-protocols-in-elixir/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2019&#x2F;02&#x2F;19&#x2F;elixir-alchemy-pouring-protocols.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Elixir has several mechanisms that allow us to write expressive and intuitive code. Pattern matching, for instance, is a powerful way of dealing with multiple scenarios without having to go into complicated branching. It allows each of our functions to be clear and concise.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-are-protocols&quot;&gt;What Are Protocols?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-are-protocols&quot; aria-label=&quot;Anchor link for: what-are-protocols&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In a way, Protocols are similar to pattern matching, but they allow us to write more meaningful and context-specific code based on the datatype weâ€™re dealing with.&lt;&#x2F;p&gt;
&lt;p&gt;Letâ€™s take the example of a content-delivery website. This website has multiple types of content: audio clips, videos, texts, and whatever else you can think of.&lt;&#x2F;p&gt;
&lt;p&gt;Each of these content types obviously has different attributes and metadata, so it makes sense for them to be represented by independent structs:&lt;&#x2F;p&gt;
&lt;p&gt;Translating this into Elixir, youâ€™d have the following structures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Content.Audio do
  defstruct [:title, :album, :artist, :duration, :bitrate, :file]
end

defmodule Content.Video do
  defstruct [:title, :cast, :release_date, :duration, :resolution, :file]
end

defmodule Content.Text do
  defstruct [:title, :author, :word_count, :chapter_count, :format, :file]
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each of these types has a few different fields, most of them unique to the type. We also have a common &lt;code&gt;:file&lt;&#x2F;code&gt; field which will point to the file keeping the actual data.&lt;&#x2F;p&gt;
&lt;p&gt;Now, letâ€™s say you want to make your content as accessible as possible. You may, for instance, want to allow your hearing-impaired users to view the transcripts of both your audio and video. For that, youâ€™ll use your awesome &lt;code&gt;AudioTranscriber&lt;&#x2F;code&gt; and &lt;code&gt;VideoTranscriber&lt;&#x2F;code&gt; modules which provide &lt;code&gt;transcribe_audio&#x2F;1&lt;&#x2F;code&gt; and &lt;code&gt;transcribe_video&#x2F;1&lt;&#x2F;code&gt; functions, respectively.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of those functions uses state-of-the-art machine learning and will be delegated to a future blog post. Letâ€™s just assume they work and roll with it.&lt;&#x2F;p&gt;
&lt;p&gt;Both transcriber modules are split up into separate modules. Aside from having different function names for transcribing content, they might be completely different libraries. To allow us to use both in a transparent manner, weâ€™ll implement a protocol named &lt;code&gt;Content.Transcribe&lt;&#x2F;code&gt; that has a unified API that can handle both types of content.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-the-protocol&quot;&gt;Implementing the Protocol&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-the-protocol&quot; aria-label=&quot;Anchor link for: implementing-the-protocol&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Using protocols, we can easily define what the act of transcribing something means to each of our data types. This is done by first defining a transcribing protocol:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defprotocol Content.Transcribe do
  def transcribe(content)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and then implementing it separately for each of our types:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defimpl Content.Transcribe, for: Content.Video do
  def transcribe(video), do: VideoTranscriber.transcribe_video(video.file)
end

defimpl Content.Transcribe, for: Content.Audio do
  def transcribe(audio), do: AudioTranscriber.transcribe_audio(audio.file)
end

defimpl Content.Transcribe, for: Content.Text do
  def transcribe(text), do: File.read(text.file)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have separately defined implementations of the same function for all 3 content types.&lt;&#x2F;p&gt;
&lt;p&gt;You may note that for text content, the implementation merely reads the corresponding file, as itâ€™s already in text format, while for the other two, we call the corresponding machine-learning-magic function on the file.&lt;&#x2F;p&gt;
&lt;p&gt;Weâ€™re then able to call &lt;code&gt;transcribe&#x2F;1&lt;&#x2F;code&gt; for all the data types we have an implementation for:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; %Content.Video{...} |&amp;gt; Content.Transcribe.transcribe()
{:ok, &amp;quot;We&amp;#x27;re no strangers to love\nYou know the rules and so do I...&amp;quot;}

iex&amp;gt; %Content.Audio{...} |&amp;gt; Content.Transcribe.transcribe()
{:ok, &amp;quot;Imagine there&amp;#x27;s no heaven\nIt&amp;#x27;s easy if you try...&amp;quot;}

iex&amp;gt; %Content.Text{...} |&amp;gt; Content.Transcribe.transcribe()
{:ok, &amp;quot;in a hole in the ground there lived a hobbit...&amp;quot;}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;fallback-implementations&quot;&gt;Fallback Implementations&lt;a class=&quot;zola-anchor&quot; href=&quot;#fallback-implementations&quot; aria-label=&quot;Anchor link for: fallback-implementations&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now, letâ€™s say we add a new type of media to our platform: games&lt;&#x2F;p&gt;
&lt;p&gt;What happens when we try to transcribe the newly-added content?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; %Content.Game{...} |&amp;gt; Content.Transcribe.transcribe()
** (Protocol.UndefinedError) protocol Content.Transcribe is not implemented for %Content.Game{...}. This protocol is implemented for: Content.Audio, Content.Text, Content.Video
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whoops! Weâ€™ve hit an error. Which makes sense. We didnâ€™t provide any transcription implementation for this type.&lt;&#x2F;p&gt;
&lt;p&gt;But it doesnâ€™t really make sense to do so, does it? Games are supposed to be interactive experiences, and there simply may be no way to make them accessible to everyone.&lt;&#x2F;p&gt;
&lt;p&gt;So we could just provide an implementation that always fails:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defimpl Content.Transcribe, for: Content.Game do
  def transcribe(game), do: {:error, &amp;quot;not supported&amp;quot;}
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But this doesnâ€™t seem very scalable, does it? If we keep adding new content types, weâ€™ll end up having to duplicate this for every single type that we cannot transcribe.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, we can simply add a fallback implementation for any type we donâ€™t specify. This is done precisely by providing an implementation for the Any type, and then stating in our protocol that we want to fall back to it when necessary.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defimpl Content.Transcribe, for: Any do
  def transcribe(_), do: {:error, &amp;quot;not supported&amp;quot;}
end

defprotocol Content.Transcribe do
  @fallback_to_any true
  def transcribe(content)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The implementation for Any can usually be used by asking Elixir to automatically derive implementations from it (you can read more about this in the official &lt;a href=&quot;https:&#x2F;&#x2F;elixir-lang.org&#x2F;getting-started&#x2F;protocols.html#deriving&quot;&gt;Elixir Getting Started guide&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;But by adding @fallback_to_any true to our protocol, weâ€™re stating that whenever a specific implementation is not found, the Any implementation should be used. This allows us to fail gracefully for any unsupported data type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; %Content.Game{...} |&amp;gt; Content.Transcribe.transcribe()
{:error, &amp;quot;not supported&amp;quot;}

iex&amp;gt; %{key: :value} |&amp;gt; Content.Transcribe.transcribe()
{:error, &amp;quot;not supported&amp;quot;}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;failed-gracefully&quot;&gt;Failed Gracefully&lt;a class=&quot;zola-anchor&quot; href=&quot;#failed-gracefully&quot; aria-label=&quot;Anchor link for: failed-gracefully&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Can we close off any better than with a graceful fail? Weâ€™ll leave you now that weâ€™ve experimented with protocols and we gracefully havenâ€™t broken any alembic today.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Understanding Elixirâ€™s GenStages: Querying the Blockchain</title>
        <published>2018-11-13T00:00:00+00:00</published>
        <updated>2018-11-13T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/understanding-elixir-genstage/" type="text/html"/>
        <id>https://naps62.com/posts/understanding-elixir-genstage/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;Note: This post was originally written on &lt;a href=&quot;https:&#x2F;&#x2F;blog.appsignal.com&#x2F;2018&#x2F;11&#x2F;13&#x2F;elixir-alchemy-understanding-elixirs-genstages-querying-the-blockchain.html&quot;&gt;AppSignal&#x27;s Elixir Alchemy Blog&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this post, weâ€™ll dive into Elixirâ€™s GenStage module. Along the way, weâ€™ll explain backpressure and weâ€™ll write a Genstage to query the blockchain. Letâ€™s start by discussing how using a GenStage can solve buffering problems.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-a-genstage&quot;&gt;What Is a GenStage?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-genstage&quot; aria-label=&quot;Anchor link for: what-is-a-genstage&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Imagine youâ€™re consuming data from an external source. That source could be anything â€œstreamableâ€ - such as reading a file line-by-line, a table in a database, or even a sequence of requests to a 3rd party API.&lt;&#x2F;p&gt;
&lt;p&gt;In such scenarios, where you need to stream data into your system, and probably do some processing on each data point, itâ€™s common to use a buffer to read in a few items, process the whole batch, and then fetch a new set into the buffer. I remember, from the time I was learning C&#x2F;C++, that this would be a common, although arguably naive way to do things.&lt;&#x2F;p&gt;
&lt;p&gt;With that approach, you may run into one of two problems: the buffer can get too small, or the buffer van get too large.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Buffer Too Small&lt;&#x2F;strong&gt; This happens if you read too few items at a time. Since youâ€™re switching back and forth between reading and processing items, there will be a performance cost from the task switching. In the example of reading a file, your hardware or Operating System may be reading more data than what youâ€™re actually requesting, resulting in sub-optimal performance, in addition to having to fetch the same part of the file later on.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Buffer Too Large&lt;&#x2F;strong&gt; In this case, you request too much from your data source. You may end up either creating a bottleneck (e.g. having to wait for your hard drive to read everything you requested), or not being able to process all the data in an efficient manner. If youâ€™ve ever heard of a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Buffer_overflow&quot;&gt;buffer overflow&lt;&#x2F;a&gt; (a common performance and security concern), this is it. Youâ€™re reading more than what your system can keep up with, resulting in all kinds of problems, from performance to actual failures.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;the-solution-backpressure&quot;&gt;The Solution: Backpressure&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-solution-backpressure&quot; aria-label=&quot;Anchor link for: the-solution-backpressure&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The term &lt;em&gt;backpressure&lt;&#x2F;em&gt; refers to the behavior of a system that builds up input, then halts the receiving of new data once the buffer is full, resuming it once again when the system is ready to handle it.&lt;&#x2F;p&gt;
&lt;p&gt;This is the core idea behind Elixirâ€™s GenStage.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;genstage&quot;&gt;GenStage&lt;a class=&quot;zola-anchor&quot; href=&quot;#genstage&quot; aria-label=&quot;Anchor link for: genstage&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;GenStage is an abstraction built on top of GenServer to provide a simple way to create a Producer&#x2F;Consumer architecture, while automatically managing the concept of backpressure.&lt;&#x2F;p&gt;
&lt;p&gt;In a GenStage, you create a pipeline of multiple Producers &amp;amp; Consumers. Producers generate data points, or read them from a source, and then pass them down to the pipeline. They can then be sent through one or more Consumers that will do whatever processing you need done.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of backpressure is applied in the way items are created in a Producer. When the pipeline is ready to receive new items, the &lt;code&gt;handle_demand&#x2F;2&lt;&#x2F;code&gt; function of the Producer is called, requesting a specific amount of items.&lt;&#x2F;p&gt;
&lt;p&gt;The amount requested is decided internally (although you can specify a maximum value), and the function is called whenever there is room for them in the pipeline. If items take too long to process, Producers end up being idle for a while, thus relieving some pressure from the system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;use-case&quot;&gt;Use Case&lt;a class=&quot;zola-anchor&quot; href=&quot;#use-case&quot; aria-label=&quot;Anchor link for: use-case&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;As an example of what a GenStage can be useful for, letâ€™s consider reading chunks of data from an external data source. In this case, weâ€™ll use the &lt;a href=&quot;https:&#x2F;&#x2F;www.ethereum.org&#x2F;&quot;&gt;Ethereum&lt;&#x2F;a&gt; blockchain, since it fits this concept nicely.&lt;&#x2F;p&gt;
&lt;p&gt;A blockchain is composed of a series of blocks, each one containing multiple transactions. If we want to process the entire blockchain (for example, to look up all transactions involving a given address, or to listen to it continuously when integrating with your application), a GenStage is a perfect fit.&lt;&#x2F;p&gt;
&lt;p&gt;In this context, each block can be considered as a single data item. Letâ€™s see how this can be achieved.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;querying-the-blockchain&quot;&gt;Querying the Blockchain&lt;a class=&quot;zola-anchor&quot; href=&quot;#querying-the-blockchain&quot; aria-label=&quot;Anchor link for: querying-the-blockchain&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Weâ€™re going to use &lt;a href=&quot;https:&#x2F;&#x2F;infura.io&#x2F;&quot;&gt;Infuraâ€™s public HTTP API&lt;&#x2F;a&gt; to interact with the Ethereum blockchain. Letâ€™s start by building a wrapper to its interface. Iâ€™ll be using the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;teamon&#x2F;tesla&quot;&gt;Tesla library&lt;&#x2F;a&gt; for this (this is just a personal preference, feel free to choose your own).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule EthSync.Infura do
  use Tesla

  plug(Tesla.Middleware.BaseUrl, &amp;quot;https:&amp;#x2F;&amp;#x2F;ropsten.infura.io&amp;#x2F;&amp;quot;)

  # encode&amp;#x2F;decode body as json
  # Infura doesn&amp;#x27;t set the &amp;quot;content-type&amp;quot; header to &amp;quot;application&amp;#x2F;json&amp;quot;
  # so we need to tell Tesla that we want text&amp;#x2F;plain requests to be decoded as well
  plug(Tesla.Middleware.JSON, decode_content_types: [&amp;quot;text&amp;#x2F;plain; charset=utf-8&amp;quot;])

  @doc &amp;quot;Get an entire block&amp;quot;
  def get_block(number) do
    case call(:eth_getBlockByNumber, [to_hex(number), true]) do
      {:ok, nil} -&amp;gt;
        {:error, :block_not_found}

      error -&amp;gt;
        error
    end
  end

  @doc &amp;quot;Sends a JSON-RPC call to the server&amp;quot;
  defp call(method, params \\ []) do
    case post(&amp;quot;&amp;quot;, %{jsonrpc: &amp;quot;2.0&amp;quot;, id: &amp;quot;call_id&amp;quot;, method: method, params: params}) do
      {:ok, %Tesla.Env{status: 200, body: %{&amp;quot;result&amp;quot; =&amp;gt; result}}} -&amp;gt;
        {:ok, result}

      {:error, _} = error -&amp;gt;
        error
    end
  end

  @doc &amp;quot;Converts integer values to hex strings&amp;quot;
  def to_hex(decimal), do: &amp;quot;0x&amp;quot; &amp;lt;&amp;gt; Integer.to_string(decimal, 16)
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Weâ€™ll only need a single endpoint for this: getting a blockâ€™s data, given its index on the chain. The block number must be given in hexadecimal format, so we also need a helper method to handle the conversion.&lt;&#x2F;p&gt;
&lt;p&gt;We can verify that this is working via &lt;code&gt;iex&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex(1)&amp;gt; EthSync.Infura.get_block(1)
{:ok,
 %{
   &amp;quot;number&amp;quot; =&amp;gt; &amp;quot;0x1&amp;quot;,
   &amp;quot;transactions&amp;quot; =&amp;gt; [],
   # ...
 }
}

iex(2)&amp;gt; EthSync.Infura.get_block(1_000_000_000_000)
{:error, :block_not_found}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;building-the-producer&quot;&gt;Building the Producer&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-producer&quot; aria-label=&quot;Anchor link for: building-the-producer&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Our Producer will be a process with the responsibility of fetching Ethereum blocks.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule EthSync.Producer2 do
  alias EthSync.Infura
  use GenStage

  def init(_) do
    {:producer, 1}
  end

  def handle_demand(demand, next_block) when demand &amp;gt; 0 do
    IO.puts(&amp;quot;Demanding #{demand}&amp;quot;)

    blocks =
      next_block..(next_block - 1 + demand)
      |&amp;gt; Enum.map(fn n -&amp;gt;
        IO.puts(&amp;quot;Fetching block #{n}&amp;quot;)
        Infura.get_block(n)
      end)

    {:noreply, blocks, next_block + length(blocks)}
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;building-the-consumer&quot;&gt;Building the Consumer&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-consumer&quot; aria-label=&quot;Anchor link for: building-the-consumer&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The Consumer will receive lists of blocks and then process them. In the example, weâ€™ll use &lt;code&gt;:timer.sleep&#x2F;1&lt;&#x2F;code&gt; to simulate processing time since weâ€™re not doing any actual work. Keep in mind that the list of blocks received is not necessarily the same as what was sent in the Producer. Items can be buffered according to the GenStageâ€™s internal rules. It may also happen that you have multiple Consumers and items get split between them.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule EthSync.Consumer do
  alias EthSync.Infura
  use GenStage

  def init(_) do
    {:consumer, nil}
  end

  def handle_events(blocks, _from, state) do
    blocks
    |&amp;gt; Enum.each(fn
      {:ok, %{&amp;quot;number&amp;quot; =&amp;gt; n}} -&amp;gt;
        IO.puts(&amp;quot;Received block #{n}&amp;quot;)
        :timer.sleep(1_000)
    end)

    {:noreply, [], state}
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;wiring-it-all-up&quot;&gt;Wiring It All Up&lt;a class=&quot;zola-anchor&quot; href=&quot;#wiring-it-all-up&quot; aria-label=&quot;Anchor link for: wiring-it-all-up&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To start the pipeline, we need to start the processes for our Producer &amp;amp; Consumer, and then link them together, so that items produced by the former get sent out to the latter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;iex&amp;gt; {:ok, producer} = GenStage.start_link(Producer2, [])
{:ok, #PID&amp;lt;0.160.0&amp;gt;}

iex&amp;gt; {:ok, consumer} = GenStage.start_link(Consumer2, [])
{:ok, #PID&amp;lt;0.162.0&amp;gt;}

iex&amp;gt; GenStage.sync_subscribe(consumer, to: producer, max_demand: 3)
{:ok, #Reference&amp;lt;0.2486793675.579338241.116277&amp;gt;}
Demanding 3
Received block 0x1
Received block 0x2
Received block 0x3
Demanding 1
Received block 0x4
Received block 0x5
Demanding 1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Notice that even though we start the Producer at the beginning, it only started fetching blocks once we wired the Consumer to it. Thatâ€™s because there was no demand until that point. Additionally, even though we specify &lt;code&gt;max_demand: 3&lt;&#x2F;code&gt;, thatâ€™s not necessarily the amount requested at all times. Since we only have a single Consumer, and it takes 1 second to process each block, the GenStage is smart enough not to overflow it with too many blocks. It adjusts the number of events as needed.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Tutorial: Deploying Elixir applications with Docker and Digital Ocean</title>
        <published>2017-05-24T00:00:00+00:00</published>
        <updated>2017-05-24T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/tutorial-deploying-elixir-applications/" type="text/html"/>
        <id>https://naps62.com/posts/tutorial-deploying-elixir-applications/</id>
        
        <content type="html">&lt;p&gt;While Elixir is becoming a popular language for web development, there is at least one topic that I still find lacking: Deploys.&lt;&#x2F;p&gt;
&lt;p&gt;There are already several options out there, but the community has not yet adopted a standard way to solve this problem, so documentation is not that easy to find or follow.&lt;&#x2F;p&gt;
&lt;p&gt;So I decided to compile what I consider to be a good standard for deploying a web application using Elixir &amp;amp; Phoenix in this post. This isn&#x27;t a one-size-fits-all solution. I would argue that there&#x27;s no such thing.&lt;&#x2F;p&gt;
&lt;p&gt;This is the solution to my particular problem:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The focus is on development speed and getting something online fast&lt;&#x2F;li&gt;
&lt;li&gt;You don&#x27;t have special infrastructure needs (think Web Server + Database + maybe Redis or a couple of other services)&lt;&#x2F;li&gt;
&lt;li&gt;You have a fast development cycle, possibly deploying to production several times every day&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;That said, if you have different requirements, this tutorial can be a good starting point to learn how to work with some of the tools, and you might be able to adapt it to your special needs, so don&#x27;t shy away just now!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;a class=&quot;zola-anchor&quot; href=&quot;#table-of-contents&quot; aria-label=&quot;Anchor link for: table-of-contents&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#elixir-releases&quot;&gt;Elixir Releases&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#isolating-the-build&quot;&gt;Isolating the build with docker&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#setting-up-compose&quot;&gt;Setting up docker-compose&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#deploying-with-docker-machine&quot;&gt;Deploying with docker-machine&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#running-migrations&quot;&gt;Running Migrations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;naps62.com&#x2F;posts&#x2F;tutorial-deploying-elixir-applications&#x2F;#final-thoughts&quot;&gt;Final thoughts&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;span id=&quot;elixir-releases&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;elixir-releases&quot;&gt;Elixir Releases&lt;a class=&quot;zola-anchor&quot; href=&quot;#elixir-releases&quot; aria-label=&quot;Anchor link for: elixir-releases&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There are two ways to get your Elixir code running on a server. The first is to push it and run &lt;code&gt;mix phx.server&lt;&#x2F;code&gt; or whichever command your application uses to start itself.&lt;&#x2F;p&gt;
&lt;p&gt;The second and most common approach is to build a release package. This is the approach I&#x27;ll be focusing in here, but if for some reason you prefer the former method, adapting this tutorial shouldn&#x27;t be hard. It mostly means you get to skip the first step.&lt;&#x2F;p&gt;
&lt;p&gt;A release is a pre-compiled form of an Elixir&#x2F;OTP application. It is stripped of anything not necessary for production use, requires almost no dependencies, and can be deployed anywhere (at least in theory, but more on that below).&lt;&#x2F;p&gt;
&lt;p&gt;There are a couple of caveats to this approach, though:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;You lose the ability to run &lt;code&gt;mix&lt;&#x2F;code&gt; or other tools, which means that database migrationsÂ and other tasks, need to be done in some other way;&lt;&#x2F;li&gt;
&lt;li&gt;You need to ensure the system architecture of the machine where the release is compiled matches the architecture of the server it&#x27;ll run on.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Both of these issues will be discussed later on in the post.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;how-do-i-build-a-release&quot;&gt;How do I build a release?&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-do-i-build-a-release&quot; aria-label=&quot;Anchor link for: how-do-i-build-a-release&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;There are a couple of tools that make it straightforward to generate releases:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;distillery&quot;&gt;&lt;code&gt;distillery&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is currently the recommended project to use;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;exrm&quot;&gt;&lt;code&gt;exrm&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a previous project by the same author. Despite having been replaced by distillery recently, it is still worth mentioning due to its heavy use. It still has it&#x27;s own page in the &lt;a href=&quot;http:&#x2F;&#x2F;www.phoenixframework.org&#x2F;v0.13.1&#x2F;docs&#x2F;advanced-deployment&quot;&gt;Phoenix framework docs&lt;&#x2F;a&gt;, for instance.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I&#x27;ll be using distillery for this tutorial. However, I won&#x27;t be using it directly, but via a Docker container, so that I can solve the system architecture problem mentioned above.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span id=&quot;isolating-the-build&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;isolating-the-build-with-docker&quot;&gt;Isolating the build with docker&lt;a class=&quot;zola-anchor&quot; href=&quot;#isolating-the-build-with-docker&quot; aria-label=&quot;Anchor link for: isolating-the-build-with-docker&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The architectures of the server and the machine where we build our release need to match. So it&#x27;s easy to see we can run into problems. We shouldn&#x27;t have to worry about breaking our builds just by using a different computer.&lt;&#x2F;p&gt;
&lt;p&gt;Building directly on the server is an option, of course, but that takes away a lot of flexibility from our hands. It would mean that our server needs all the dependencies necessary to build a release, and will also spend some computing power from our server, which might have noticeable effects, especially if you&#x27;re on a budget.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, how about delegating the build process to a Docker container? That way, we ensure consistency, regardless of where we trigger the build. In the docker community, this is usually referred to as the &lt;a href=&quot;http:&#x2F;&#x2F;blog.terranillius.com&#x2F;post&#x2F;docker_builder_pattern&#x2F;&quot;&gt;Builder Pattern&lt;&#x2F;a&gt;.
We&#x27;ll have one Docker container to build the release package, and a different one for running it, with only the bare minimum runtime dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;And that&#x27;s exactly what &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Recruitee&#x2F;mix_docker&quot;&gt;&lt;code&gt;mix_docker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; does for us. Out of the box, it includes two different Dockerfile descriptions, which are used to, respectively, build and release your Elixir app. Under the hood, it uses &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitwalker&#x2F;distillery&quot;&gt;&lt;code&gt;distillery&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to generate the releases.&lt;&#x2F;p&gt;
&lt;p&gt;Note: We could also take advantage of Docker&#x27;s new feature: &lt;a href=&quot;https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;eng-image&#x2F;multistage-build&#x2F;#use-multi-stage-builds&quot;&gt;Multi-stage builds&lt;&#x2F;a&gt;, but mix_docker does not yet support those, so we&#x27;re going with the two Dockerfile approach for convenience.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;building-a-release&quot;&gt;Building a Release&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-a-release&quot; aria-label=&quot;Anchor link for: building-a-release&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To set it up, add &lt;code&gt;mix_docker&lt;&#x2F;code&gt; to your &lt;code&gt;mix.exs&lt;&#x2F;code&gt; , and run &lt;code&gt;mix deps.get&lt;&#x2F;code&gt; . At the time of writing, the released version (0.3.0) does not work with Erlang 19, so I had to fetch the Github repo directly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;def deps do
  [
    ...
    {:mix_docker, github: &amp;quot;Recruitee&amp;#x2F;mix_docker&amp;quot;},
  ]
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And set it up using:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ mix docker.init
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will setup Distillery as well, creating a &lt;code&gt;rel&#x2F;config.exs&lt;&#x2F;code&gt; file in your project.&lt;&#x2F;p&gt;
&lt;p&gt;You might be interested in checking out &lt;a href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;distillery&#x2F;getting-started.html#configuration&quot;&gt;Distillery&#x27;s Configuration options&lt;&#x2F;a&gt; and change that file if you need to.&lt;&#x2F;p&gt;
&lt;p&gt;Next, to build a release, run:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ mix docker.build
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This copies your entire application to a minimal Docker image running Alpine Linux. The image contains only the essential packages to build your application, which is nothing more than an Erlang&#x2F;Elixir installation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;releasing-a-release&quot;&gt;Releasing a Release&lt;a class=&quot;zola-anchor&quot; href=&quot;#releasing-a-release&quot; aria-label=&quot;Anchor link for: releasing-a-release&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;We now want this build to run on our server. For that, &lt;code&gt;mix_docker&lt;&#x2F;code&gt; provides another docker image and a command:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ mix docker.release
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;An Elixir release is a self-contained project that requires no dependencies (at least for a simple project, as is the case here), so this second container has nothing more than the same Alpine Linux installation with a couple of system libraries, making it very compact.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;publishing-to-docker-hub&quot;&gt;Publishing to Docker Hub&lt;a class=&quot;zola-anchor&quot; href=&quot;#publishing-to-docker-hub&quot; aria-label=&quot;Anchor link for: publishing-to-docker-hub&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now we have a docker image that runs our app. Everything is contained there, so we just need to get that on a server. I use &lt;a href=&quot;https:&#x2F;&#x2F;hub.docker.com&#x2F;&quot;&gt;Docker Hub&lt;&#x2F;a&gt; for that since it integrates nicely with the rest of the Docker toolkit.&lt;&#x2F;p&gt;
&lt;p&gt;You need to set up an account and run &lt;code&gt;docker login&lt;&#x2F;code&gt; to connect locally.&lt;&#x2F;p&gt;
&lt;p&gt;On the free plan, it allows only one private repository, which fortunately is enough for me. If that doesn&#x27;t suit your needs, you can look into alternatives, such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.docker.com&#x2F;registry&#x2F;deploying&#x2F;&quot;&gt;hosting your own private Docker Registry&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Keeping with the Docker Hub approach:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ mix docker.publish --tag 0.1.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since my docker username is &lt;code&gt;naps62&lt;&#x2F;code&gt;, and considering &lt;code&gt;demo&lt;&#x2F;code&gt; as the name of this particular project, this would upload an image called &lt;code&gt;naps62&#x2F;demo:0.1.0&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Having that out of the way, we still need a few things to make the containerized app work:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Setting up any environment variables that might be necessary;&lt;&#x2F;li&gt;
&lt;li&gt;Adding a database container as a dependency.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In the next section, I&#x27;ll explain how to use &lt;a href=&quot;https:&#x2F;&#x2F;docs.docker.com&#x2F;compose&#x2F;&quot;&gt;Docker Compose&lt;&#x2F;a&gt; to do just that.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span id=&quot;setting-up-compose&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;setting-up-docker-compose&quot;&gt;Setting up docker-compose&lt;a class=&quot;zola-anchor&quot; href=&quot;#setting-up-docker-compose&quot; aria-label=&quot;Anchor link for: setting-up-docker-compose&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Compose is a tool that allows us to define and run a multi-container app, specifying how the networking and dependencies between them should work. Think of it as a low-scale orchestration tool.&lt;&#x2F;p&gt;
&lt;p&gt;To use it for our app, we need to create a &lt;code&gt;docker-compose.yml&lt;&#x2F;code&gt; looking like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;version: &amp;#x27;2.0&amp;#x27;
services:
  web:
    image: &amp;#x27;naps62&amp;#x2F;demo:0.1.0&amp;#x27;
    command: foreground
    depends_on:
      - db
    ports:
      - &amp;#x27;4000:4000&amp;#x27;
    environment:
      DATABASE_URL: &amp;#x27;ecto:&amp;#x2F;&amp;#x2F;demo_db:demo_user@db&amp;#x2F;demo_db&amp;#x27;
      PORT: 4000
      POOL_SIZE: 10

  db:
    image: postgres:9.6.2
    environment:
      POSTGRES_DB: &amp;#x27;demo_db&amp;#x27;
      POSTGRES_USER: &amp;#x27;demo_user&amp;#x27;
      POSTGRES_PASSWORD: &amp;#x27;demo_pass&amp;#x27;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I won&#x27;t go through in much detail since there are already a lot of tutorials covering Docker Compose ( &lt;a href=&quot;https:&#x2F;&#x2F;docs.docker.com&#x2F;compose&#x2F;gettingstarted&#x2F;&quot;&gt;exhibit A&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;blog.codeship.com&#x2F;orchestrate-containers-for-development-with-docker-compose&#x2F;&quot;&gt;exhibit B&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;thoughtbot.com&#x2F;upcase&#x2F;videos&#x2F;intro-to-docker&quot;&gt;exhibit C&lt;&#x2F;a&gt; ). I&#x27;ll just to go through the relevant parts for this tutorial:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;image: &amp;quot;naps62&#x2F;demo:0.1.0&amp;quot;&lt;&#x2F;code&gt; refers to the image we just built. Notice the tag must be updated if we release a new version. Or alternatively, we can use &lt;code&gt;image: &amp;quot;naps62&#x2F;demo:${TAG}&amp;quot;&lt;&#x2F;code&gt; to get the release tag from an environment variable, making it easier to update it in the future;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;command: foreground&lt;&#x2F;code&gt; this is the command to be executed by the docker image. &lt;code&gt;foreground&lt;&#x2F;code&gt; just appends to be the executable included in a docker release to start the app. Other alternatives are available if we need to start it as a background job, but that is not what we need here;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;ports: &amp;quot;4000:4000&amp;quot;&lt;&#x2F;code&gt; sets the port forwarding to the default port used by the Phoenix server. We&#x27;ll later add an nginx reverse proxy to redirect requests to this port;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DATABASE_URL: &amp;quot;ecto:&#x2F;&#x2F;..&amp;quot;&lt;&#x2F;code&gt; This sets the full URL for Ecto to connect to our PostgreSQL database, which is running in a separate container. It contains the username, password, and database name;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For that &lt;code&gt;DATABASE_URL&lt;&#x2F;code&gt; variable to be used, we also need to change our Ecto configs for production:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;## config&amp;#x2F;prod.exs

config :db, Demo.Repo,
  adapter: Ecto.Adapters.Postgres,
  url: {:system, &amp;quot;DATABASE_URL&amp;quot;},
  pool_size: 10,
  ssl: false m
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this setup, we can get our entire system running with &lt;code&gt;docker-compose up&lt;&#x2F;code&gt;. But we want to do that on a remote server, not locally, so let&#x27;s dive into that now:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span id=&quot;deploying-with-docker-machine&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deploying-with-docker-machine&quot;&gt;Deploying with Docker Machine&lt;a class=&quot;zola-anchor&quot; href=&quot;#deploying-with-docker-machine&quot; aria-label=&quot;Anchor link for: deploying-with-docker-machine&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Docker Machine is yet another tool in the large Docker ecosystem. It is used to handle docker installations and containers in remote machines without all the hassle of setting up a server manually and &lt;code&gt;ssh&lt;&#x2F;code&gt; &#x27;ing into it.&lt;&#x2F;p&gt;
&lt;p&gt;In this case, we&#x27;ll be using it to create a Digital Ocean droplet (via their API, not manually), and run our app.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;grab-your-digital-ocean-token&quot;&gt;Grab your Digital Ocean token&lt;a class=&quot;zola-anchor&quot; href=&quot;#grab-your-digital-ocean-token&quot; aria-label=&quot;Anchor link for: grab-your-digital-ocean-token&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;You&#x27;ll need to get an API token from your Digital Ocean account so that Docker Machine can have access to it.&lt;&#x2F;p&gt;
&lt;p&gt;Go to &lt;a href=&quot;https:&#x2F;&#x2F;cloud.digitalocean.com&#x2F;settings&#x2F;api&#x2F;tokens&quot;&gt;https:&#x2F;&#x2F;cloud.digitalocean.com&#x2F;settings&#x2F;api&#x2F;tokens&lt;&#x2F;a&gt; and create a new token:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;notion-static&#x2F;4e595b7b24fc4ba0994a2c492f247b5f&#x2F;2017-05-10-163456_1135x433_scrot.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now, copy it to your terminal as an environment variable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ export DIGITAL_OCEAN_TOKEN=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;bonus-persist-your-token-with-a-secrets-file&quot;&gt;Bonus: Persist your token with a secrets file&lt;a class=&quot;zola-anchor&quot; href=&quot;#bonus-persist-your-token-with-a-secrets-file&quot; aria-label=&quot;Anchor link for: bonus-persist-your-token-with-a-secrets-file&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To make this persistent, and prevent you from having to export this variable on every new terminal, you can create a &lt;code&gt;~&#x2F;.secrets.sh&lt;&#x2F;code&gt; with the export command, and load it in your &lt;code&gt;.bashrc&lt;&#x2F;code&gt; or &lt;code&gt;.zshrc&lt;&#x2F;code&gt; :&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;[ -f ~&amp;#x2F;.secrets.sh ] &amp;amp;&amp;amp; source ~&amp;#x2F;.secrets.sh
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Just remember not to commit this to your dotfiles repository, if you have one. And, of course, this is only an option if you have enough control over who uses your computer, so tread lightly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;create-droplet&quot;&gt;Create Droplet&lt;a class=&quot;zola-anchor&quot; href=&quot;#create-droplet&quot; aria-label=&quot;Anchor link for: create-droplet&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Creating a droplet on Digital Ocean can be done with a single Docker Machine command, which will use the Digital Ocean API to do most of the work for us. Let&#x27;s create a droplet called &lt;code&gt;docker-demo&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ docker-machine create --driver=digitalocean --digitalocean-access-token=$DIGITAL_OCEAN_TOKEN --digitalocean-size=512mb docker-demo
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That&#x27;s it! The new droplet has Docker up and running, and an SSH key was created automatically for you, allowing you to run &lt;code&gt;docker-machine ssh docker-demo&lt;&#x2F;code&gt; to access its shell if needed.&lt;&#x2F;p&gt;
&lt;p&gt;But to deploy our app, there&#x27;s an even easier way.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;running-docker-compose-remotely&quot;&gt;Running Docker Compose remotely&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-docker-compose-remotely&quot; aria-label=&quot;Anchor link for: running-docker-compose-remotely&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Docker Compose supports running containers on remote hosts rather than locally. For this, only a few environment variables are needed to point to the correct host, and Docker Machine also has us covered there:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ eval $(docker-machine env docker-demo)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After running the above command, our terminal will have set &lt;code&gt;DOCKER_HOST&lt;&#x2F;code&gt; and a couple of other variables, pointing to the droplet we created.&lt;&#x2F;p&gt;
&lt;p&gt;And just like magic, we can now seamlessly start our docker containers on that host:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ docker-compose up -d
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All of Compose&#x27;s commands will work as before, but their effects will happen remotely instead. The &lt;code&gt;-d&lt;&#x2F;code&gt; option ensures the containers are run as a background process, so our app is now fully running. You can run &lt;code&gt;docker-compose ps&lt;&#x2F;code&gt; to see the proof&lt;&#x2F;p&gt;
&lt;p&gt;Once you&#x27;re done, you can either open a new terminal or run &lt;code&gt;eval $(docker-machine env -u)&lt;&#x2F;code&gt; to unset the environment variables and go back to local mode.&lt;&#x2F;p&gt;
&lt;p&gt;Now our app is running in a remote droplet, but it&#x27;s not yet accessible to the outside world. Let&#x27;s fix that with an nginx reverse proxy.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nginx-reverse-proxy&quot;&gt;Nginx reverse proxy&lt;a class=&quot;zola-anchor&quot; href=&quot;#nginx-reverse-proxy&quot; aria-label=&quot;Anchor link for: nginx-reverse-proxy&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We first need to install nginx on the droplet, since it doesn&#x27;t come pre-installed:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ docker-machine ssh docker-demo
root@docker-demo:~$ sudo apt-get install nginx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All that&#x27;s left is a simple nginx configuration, pointing all requests to port 4000, which we previously exposed in our Compose configuration. Add the following as &lt;code&gt;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;your-website.conf&lt;&#x2F;code&gt;, replacing &lt;code&gt;your-website.com&lt;&#x2F;code&gt; with the actual URL you want to use:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nginx&quot; class=&quot;language-nginx &quot;&gt;&lt;code class=&quot;language-nginx&quot; data-lang=&quot;nginx&quot;&gt;upstream your-website {
  server 127.0.0.1:4000;
}

server {
  listen 80;
  server_name [your-website.com](http:&amp;#x2F;&amp;#x2F;your-website.com) www.your-website.com;

  location &amp;#x2F; {
    proxy_pass http:&amp;#x2F;&amp;#x2F;your-website;
    proxy_redirect off;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Host $server_name;
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After this, run &lt;code&gt;service nginx start&lt;&#x2F;code&gt; to start the process. If you already did the previous &lt;code&gt;docker-compose up -d&lt;&#x2F;code&gt;, then your app should now be accessible. Congratulations!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span id=&quot;running-migrations&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;running-migrations&quot;&gt;Running migrations&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-migrations&quot; aria-label=&quot;Anchor link for: running-migrations&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Now that you successfully deployed an Elixir web app, you need to take care of updates as well. One of the most common maintenance tasks of updating an app is to run database migrations.&lt;&#x2F;p&gt;
&lt;p&gt;In development, you usually do this by running &lt;code&gt;mix ecto.migrate&lt;&#x2F;code&gt; , but you might remember that, at the beginning of the post, I mentioned that this is not an option for release builds.Â The mix interface is not available in production, so we need a different solution.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, it is really easy to run migrations programmatically, and both Ecto and Distillery provide us with the necessary tools.&lt;&#x2F;p&gt;
&lt;p&gt;With Distillery, we can specify hook scripts that will be executed when our app first starts. And through these scripts, we can make an RPC call to our app, triggering some code that will run the migration.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;running-migrations-programmatically&quot;&gt;Running migrations programmatically&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-migrations-programmatically&quot; aria-label=&quot;Anchor link for: running-migrations-programmatically&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Define the following module somewhere in your codebase:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;defmodule Demo.Release.Tasks do
  def migrate do
     {:ok, _} = Application.ensure_all_started(:demo)

     path = Application.app_dir(:demo, &amp;quot;priv&amp;#x2F;repo&amp;#x2F;migrations&amp;quot;)

    Ecto.Migrator.run(Demo.Repo, path, :up, all: true)
  end
end
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This calls the Ecto API, which goes through your migrations and runs any new ones.&lt;&#x2F;p&gt;
&lt;p&gt;We now need to trigger this code to be called when our app is deployed, using a hook that Distillery provides us. Edit the production section of your &lt;code&gt;rel&#x2F;config.exs&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;...

environment :prod do
  ...

  # add this line
  set post_start_hook: &amp;quot;rel&amp;#x2F;hooks&amp;#x2F;post_start&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This references a &lt;code&gt;rel&#x2F;hooks&#x2F;post_start&lt;&#x2F;code&gt; file, which we will now create. This is actually a regular shell script where we can do whatever we need.&lt;&#x2F;p&gt;
&lt;p&gt;In this case, we&#x27;re going to use RPC to call the Elixir function defined above:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;##!&amp;#x2F;bin&amp;#x2F;sh

set +e

while true; do
  nodetool ping
  EXIT_CODE=$?

  if [ $EXIT_CODE -eq 0 ]; then
    echo &amp;quot;Application is up!&amp;quot;
    break
  fi
done

set =e

echo &amp;quot;Running migrations&amp;quot;
bin&amp;#x2F;demo rpc Elixir.Release.Tasks migrate
echo &amp;quot;Migrations run successfully&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now every time the app is deployed, our migration task will be called.&lt;&#x2F;p&gt;
&lt;p&gt;You can see that this is not tied to database migrations in any way. We can easily add other kinds of tasks to this hook, making it a very generic way of having additional deployment tasks running.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;span id=&quot;final-thoughts&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;a class=&quot;zola-anchor&quot; href=&quot;#final-thoughts&quot; aria-label=&quot;Anchor link for: final-thoughts&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If you enjoyed this tutorial, or if you have any questions feel free to reach me out through &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;naps62&quot;&gt;Twitter&lt;&#x2F;a&gt; or via the comments below.&lt;&#x2F;p&gt;
&lt;p&gt;Or, if you&#x27;re ready to take it to the next step, you can also take some hints from our tutorial for &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;130-how-to-build-offline-web-applications-with-couchdb-and-pouchdb&quot;&gt;building offline web applications&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Super-powered Vim, part I: Projections</title>
        <published>2017-04-04T00:00:00+00:00</published>
        <updated>2017-04-04T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/super-powered-vim-i-projections/" type="text/html"/>
        <id>https://naps62.com/posts/super-powered-vim-i-projections/</id>
        
        <content type="html">&lt;p&gt;One of my main focus of the past few months has been my productivity with my text editor.
This text editor happens to be &lt;a href=&quot;http:&#x2F;&#x2F;www.vim.org&#x2F;&quot;&gt;Vim&lt;&#x2F;a&gt;, but the concepts of this post are applicable to any code-editing tool.&lt;&#x2F;p&gt;
&lt;p&gt;The main focus of this 3-part series is to minimise time spent on the boring and repetitive parts of writing code.&lt;&#x2F;p&gt;
&lt;p&gt;For now, let&#x27;s focus on how dull of a task it is to navigate your codebase:&lt;&#x2F;p&gt;
&lt;h2 id=&quot;filesystems-are-boring&quot;&gt;Filesystems are boring&lt;a class=&quot;zola-anchor&quot; href=&quot;#filesystems-are-boring&quot; aria-label=&quot;Anchor link for: filesystems-are-boring&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;When working on a given feature, I&#x27;ll probably be navigating between 2 or more files at a time. For instance:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;When working on a model class, I&#x27;ll probably touch the corresponding test files for that class as well;&lt;&#x2F;li&gt;
&lt;li&gt;When working on a React.js component, it&#x27;s likely I&#x27;ll have to touch the corresponding CSS file.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Navigating between these pairs of files might prove slightly difficult, especially if I have to do it several times during the same task. Even a couple of seconds of context switching can amount to a large time at the end of the day.&lt;&#x2F;p&gt;
&lt;p&gt;Using a component based approach, where all the files related to a given component or domain are stored next to each other, might alleviate this pain.
But for me, that&#x27;s not necessarily a good solution.&lt;&#x2F;p&gt;
&lt;p&gt;The way I move about my code should not be coupled to what the file structure looks like. As developers, we can come up with much more powerful and context-aware methods of finding stuff.&lt;&#x2F;p&gt;
&lt;p&gt;And that&#x27;s what &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-projectionist&quot;&gt;&lt;code&gt;vim-projectionist&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is all about.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;defining-projections&quot;&gt;Defining projections&lt;a class=&quot;zola-anchor&quot; href=&quot;#defining-projections&quot; aria-label=&quot;Anchor link for: defining-projections&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There are several useful features within &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-projectionist&quot;&gt;&lt;code&gt;tpope&#x2F;vim-projectionist&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. But the killer for me is the ability to define an alternate for each file.&lt;&#x2F;p&gt;
&lt;p&gt;With a simple configuration based on the naming of your files, you can create &amp;quot;pairs&amp;quot; of files. This can be done with a &lt;code&gt;.projections.json&lt;&#x2F;code&gt; file in your repository:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;{
  &amp;quot;app&amp;#x2F;*.rb&amp;quot;: { &amp;quot;alternate&amp;quot;: &amp;quot;spec&amp;#x2F;{}_spec.rb&amp;quot; },
  &amp;quot;spec&amp;#x2F;*_spec.rb&amp;quot;: { &amp;quot;alternate&amp;quot;: &amp;quot;app&amp;#x2F;{}.rb&amp;quot; }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this simple mapping, we&#x27;re defining a rule where for every file in the &lt;code&gt;app&lt;&#x2F;code&gt; directory, there&#x27;s an alternate file in the &lt;code&gt;spec&lt;&#x2F;code&gt; directory, with a matching name and a trailing &lt;code&gt;_spec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;{}&lt;&#x2F;code&gt; placeholder will be filled with whatever matches the &lt;code&gt;*&lt;&#x2F;code&gt; for each file.
This might not be the case 100% of the times, but it matches the conventions normally used for Rails apps, so it&#x27;s a pretty good approximation.&lt;&#x2F;p&gt;
&lt;p&gt;The second projection in the file defines the projection in the opposite direction.&lt;&#x2F;p&gt;
&lt;p&gt;With these pairings in place, I can use simple commands to navigate between a file and its corresponding alternate:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;subvisual.s3.amazonaws.com&#x2F;blog&#x2F;post_image&#x2F;239&#x2F;original.gif&quot; alt=&quot;file&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I can switch to the alternate file, or open it in a split or tab, with commands such as &lt;code&gt;:A&lt;&#x2F;code&gt; or &lt;code&gt;:AV&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s then just a matter of setting up some key maps to make this even easier:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;map &amp;lt;leader&amp;gt;aa :A&amp;lt;CR&amp;gt;
map &amp;lt;leader&amp;gt;av :AV&amp;lt;CR&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This prevents me from having to think about the directory structure a project is using, and instead focus on actual work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;system-wide-projections&quot;&gt;System wide projections&lt;a class=&quot;zola-anchor&quot; href=&quot;#system-wide-projections&quot; aria-label=&quot;Anchor link for: system-wide-projections&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s pretty useful to be able to define projections for each individual project. But there might be cases where you&#x27;ll end up using the same ones over and over. For instance, in a Rails app, you probably want to add a map between code files and spec files to always exist.&lt;&#x2F;p&gt;
&lt;p&gt;So we can instead make this a system-wide configuration, by applying it to our vim settings directly.&lt;&#x2F;p&gt;
&lt;p&gt;An efficient way to do that is via syntax specific files, so that each set of global projections only gets loaded when needed. Vim-projectionist also provides us with a callback that we can use to lazy-load them only when necessary:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;## ~&amp;#x2F;.vim&amp;#x2F;syntax&amp;#x2F;ruby.vim

autocmd User ProjectionistDetect
\ call projectionist#append(getcwd(),
\ {
\    &amp;#x27;app&amp;#x2F;*.rb&amp;#x27;: {
\      &amp;#x27;alternate&amp;#x27;: &amp;#x27;spec&amp;#x2F;{}_spec.rb&amp;#x27;
\    },
\    &amp;#x27;spec&amp;#x2F;*_spec.rb&amp;#x27;: {
\      &amp;#x27;alternate&amp;#x27;: &amp;#x27;app&amp;#x2F;{}.rb&amp;#x27;
\    },
\ })
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s kind of awkward to define a json schema inline within a VimL file. But hey, it works!
These projections are now global, and are loaded only when necessary, whenever I invoke a projectionist method within a Ruby file.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In good ol&#x27; Hollywood fashion, this post is part of a trilogy. In &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;134-super-powered-vim-part-ii-snippets&quot;&gt;part II&lt;&#x2F;a&gt;, I&#x27;ll talk about a different concept - snippets - and how I build my own dynamic snippets for Vim.
Later, in &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;135-super-powered-vim-part-iii-skeletons&quot;&gt;part III&lt;&#x2F;a&gt;, I&#x27;ll explain an awesome integration that can be done between &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tpope&#x2F;vim-projectionist&quot;&gt;&lt;code&gt;vim-projectionist&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and these snippets, to go even further in the art of &lt;em&gt;not writing code&lt;&#x2F;em&gt;â„¢.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Super-powered Vim, part II: Snippets</title>
        <published>2017-04-04T00:00:00+00:00</published>
        <updated>2017-04-04T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/super-powered-vim-ii-snippets/" type="text/html"/>
        <id>https://naps62.com/posts/super-powered-vim-ii-snippets/</id>
        
        <content type="html">&lt;p&gt;This post is a follow-up to &lt;a href=&quot;&#x2F;posts&#x2F;super-powered-vim-i-projections&quot;&gt;Super-powered Vim, part I: Projections&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Keeping the same line of thought of the previous post, about taking the effort out of the boring tasks that come with writing code, let&#x27;s now talk about a simple yet powerful concept: snippets.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;writing-code-is-boring&quot;&gt;Writing code is boring&lt;a class=&quot;zola-anchor&quot; href=&quot;#writing-code-is-boring&quot; aria-label=&quot;Anchor link for: writing-code-is-boring&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Open up three different code files in your current project. Now look at them, and compare them.&lt;&#x2F;p&gt;
&lt;p&gt;Chances are you&#x27;ll see a lot of duplication between them. Maybe not the duplication that you can refactor away though. But, and let&#x27;s assume here we&#x27;re talking about a Ruby project, you&#x27;re seeing something along these lines:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;All 3 files have a class or module, named after the path and file they&#x27;re in;&lt;&#x2F;li&gt;
&lt;li&gt;For classes, there might be a constructor that sets up some instance variables;&lt;&#x2F;li&gt;
&lt;li&gt;You probably have a corresponding test file somewhere, with the same RSpec boilerplate you use everywhere.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Ever thought about not having to write most of this anymore?&lt;&#x2F;p&gt;
&lt;p&gt;As I said above, this is all duplicated code. And while we cannot refactor our app to remove that duplication (without coming up with a new programming language, at least), we can surely make our editor do the heavy-lifting for us:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;subvisual.s3.amazonaws.com&#x2F;blog&#x2F;post_image&#x2F;247&#x2F;original.gif&quot; alt=&quot;file&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the above image, I&#x27;m using two snippets created with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SirVer&#x2F;ultisnips&quot;&gt;UltiSnips&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The first one, invoked with the keyword &lt;code&gt;class&lt;&#x2F;code&gt; creates a Ruby class, naming it after the path and filename where currently editing. The snippet is intelligent enough to know that &lt;code&gt;app&#x2F;models&#x2F;my_namespace&#x2F;a_very_long_class_name.rb&lt;&#x2F;code&gt; should probably hold a &lt;code&gt;MyNamespace::AVeryLongClassName&lt;&#x2F;code&gt; class. This is most likely the desired name for the class (following Ruby conventions) so the snippet goes with it as the default.&lt;&#x2F;li&gt;
&lt;li&gt;Afterwards, I&#x27;m using a &lt;code&gt;defi&lt;&#x2F;code&gt; snippet which sets up a Ruby initializer method. This does even more magic behind the curtains so that as I type new arguments in the method header, these get added as instance variable assignments in the body.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;You can start to see the power of this approach, as with just some small keywords and a shortcut, I can easily insert any kind of boilerplate code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;but-how&quot;&gt;But how?&lt;a class=&quot;zola-anchor&quot; href=&quot;#but-how&quot; aria-label=&quot;Anchor link for: but-how&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;UltiSnips is powered by Python and it has the extremely useful feature of allowing us to introduce actual Python code within the snippets. This code will be evaluated in real time, as we expand and complete snippets. Here&#x27;s the code for that &lt;code&gt;class&lt;&#x2F;code&gt; snippet I showed earlier:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;snippet class &amp;quot;class definition&amp;quot;
class `!p rb_class_name(path, snip)`
  $0
end
endsnippet
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There&#x27;s a [great series of screencasts] that explains very well how to use UltiSnips, so I won&#x27;t go into detail here. The only thing worth mentioning is that &lt;code&gt;!p rb_class_name(path, snip)&lt;&#x2F;code&gt; defines a block of Python code.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;rb_class_name&lt;&#x2F;code&gt; is a simple function I defined in a helper file that does the necessary text transformations to the file path (given as argument) to infer the name of the Ruby class.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;This was all very cool and whatnot, but there are still a few keystrokes we can shave off of this.&lt;&#x2F;p&gt;
&lt;p&gt;Typing that &lt;code&gt;class&lt;&#x2F;code&gt; snippet and expanding it for every new file will be a bit boring, won&#x27;t it?&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;135-super-powered-vim-part-iii-skeletons&quot;&gt;part III&lt;&#x2F;a&gt;, I&#x27;ll explain how we can integrate &lt;code&gt;vim-projectionist&lt;&#x2F;code&gt; (mentioned in &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;133-super-powered-vim-part-i-projections&quot;&gt;part I&lt;&#x2F;a&gt;) with snippets to go even further in the art of &lt;em&gt;not writing code&lt;&#x2F;em&gt;â„¢.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Super-powered Vim, part III: Skeletons</title>
        <published>2017-04-04T00:00:00+00:00</published>
        <updated>2017-04-04T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/super-powered-vim-iii-skeletons/" type="text/html"/>
        <id>https://naps62.com/posts/super-powered-vim-iii-skeletons/</id>
        
        <content type="html">&lt;p&gt;This post is the third of a three-part series. If you&#x27;re interested, you can start by checking out &lt;a href=&quot;&#x2F;posts&#x2F;super-powered-vim-i-projections&quot;&gt;part I&lt;&#x2F;a&gt; and &lt;a href=&quot;&#x2F;super-powered-vim-ii-snippets&quot;&gt;part II&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Writing code is boring.&lt;&#x2F;p&gt;
&lt;p&gt;In the previous parts I showed how we could speed things up a bit, by having some powerful shortcuts for file navigation and inserting repeatable blocks of code (snippets).&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s see how we can go one step further:&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s stick with Ruby as our sample language. The common practice in the community is to have a class or module in each file, with the name matching the file path. So &lt;code&gt;app&#x2F;models&#x2F;user.rb&lt;&#x2F;code&gt; will have a &lt;code&gt;class User&lt;&#x2F;code&gt;, and &lt;code&gt;app&#x2F;models&#x2F;foo&#x2F;bar.rb&lt;&#x2F;code&gt; will have a &lt;code&gt;class Foo::Bar&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So wouldn&#x27;t it be pretty cool if, when creating one of these files, it got be pre-populated by that class definition?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wait-what&quot;&gt;Wait... What?&lt;a class=&quot;zola-anchor&quot; href=&quot;#wait-what&quot; aria-label=&quot;Anchor link for: wait-what&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;134-super-powered-vim-part-ii-snippets&quot;&gt;part II&lt;&#x2F;a&gt;, I already mentioned a &lt;code&gt;class&lt;&#x2F;code&gt; snippet, which creates a Ruby class based on the path of the file.&lt;&#x2F;p&gt;
&lt;p&gt;Now I want this snippet to be automatically inserted in any new files created in the &lt;code&gt;app&lt;&#x2F;code&gt; directory.&lt;&#x2F;p&gt;
&lt;p&gt;Could we define some kind of attribute for these paths? Say... a projection?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take the &lt;code&gt;.projections.json&lt;&#x2F;code&gt; example from &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;133-super-powered-vim-part-i-projections&quot;&gt;part I&lt;&#x2F;a&gt; and expand it a bit:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;{
  &amp;quot;app&amp;#x2F;*.rb&amp;quot;: {
    &amp;quot;alternate&amp;quot;: &amp;quot;spec&amp;#x2F;{}_spec.rb&amp;quot;,
    &amp;quot;skeleton&amp;quot;: &amp;quot;class&amp;quot;
  },
  &amp;quot;spec&amp;#x2F;*_spec.rb&amp;quot;: {
    &amp;quot;alternate&amp;quot;: &amp;quot;app&amp;#x2F;{}.rb&amp;quot;,
    &amp;quot;skeleton&amp;quot;: &amp;quot;spec&amp;quot;
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We now have a &lt;code&gt;skeleton&lt;&#x2F;code&gt; attribute for both &lt;code&gt;app&lt;&#x2F;code&gt; and &lt;code&gt;spec&lt;&#x2F;code&gt; files. &lt;code&gt;class&lt;&#x2F;code&gt; and &lt;code&gt;spec&lt;&#x2F;code&gt; are snippet names, which insert a class definition, and some RSpec boilerplate, respectively.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s look at some vimscript magic (I know... sorry):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;augroup UltiSnips_custom
  autocmd!
  autocmd BufNewFile * silent! call skel#InsertSkeleton()
augroup END
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is defining an autogroup (&lt;a href=&quot;http:&#x2F;&#x2F;learnvimscriptthehardway.stevelosh.com&#x2F;chapters&#x2F;14.html&quot;&gt;more on what that is here&lt;&#x2F;a&gt;) that listens to the &lt;code&gt;BufNewFile&lt;&#x2F;code&gt; event. This event is called when a buffer is created for a new file (i.e.: a file that is not yet persisted to disk). All of this happens when we do the &lt;code&gt;:edit&lt;&#x2F;code&gt; command for with a non-existing path.&lt;&#x2F;p&gt;
&lt;p&gt;That command will then call the &lt;code&gt;skel#InsertSkeleton&lt;&#x2F;code&gt; function (see the code snippet at the end of the post for its definition). In short, the function will:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Make sure the buffer does not exist and is empty (we probably don&#x27;t want to do anything in these cases)&lt;&#x2F;li&gt;
&lt;li&gt;Loop through the existing projections, to look for a &lt;code&gt;skeleton&lt;&#x2F;code&gt; key matching the current file path&lt;&#x2F;li&gt;
&lt;li&gt;If a skeleton is found, insert the snippet&#x27;s name, and expand it using the appropriate function from UltiSnips.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For the example of &lt;code&gt;app&#x2F;models&#x2F;foo.rb&lt;&#x2F;code&gt;, this will literally insert the word &lt;code&gt;class&lt;&#x2F;code&gt; into the buffer, and call &lt;code&gt;UltiSnips#ExpandSnippet()&lt;&#x2F;code&gt; for us, creating the class definition.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;i.imgur.com&#x2F;Efolbol.gif&quot; alt=&quot;magic&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;but-wait-there-s-more&quot;&gt;But wait, there&#x27;s more&lt;a class=&quot;zola-anchor&quot; href=&quot;#but-wait-there-s-more&quot; aria-label=&quot;Anchor link for: but-wait-there-s-more&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;You just created a Ruby class by simply opening a new file.&lt;&#x2F;p&gt;
&lt;p&gt;Now you want to write some tests for it, so you use your newly learnt &lt;code&gt;vim-projectionist&lt;&#x2F;code&gt; skills, and type &lt;code&gt;:A&lt;&#x2F;code&gt; (or whatever shortcut you have) to go to it&#x27;s alternate file, as defined by the projections. This should match to &lt;code&gt;spec&#x2F;models&#x2F;foo_spec.rb&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This file also does not exist, but &lt;code&gt;vim-projectionist&lt;&#x2F;code&gt; is aware of this (see &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;133-super-powered-vim-part-i-projections&quot;&gt;part I&lt;&#x2F;a&gt; for more on this). This will conveniently ask you if you want to create it on the fly.&lt;&#x2F;p&gt;
&lt;p&gt;Once you accept to do so, the same events will be triggered, and this time, the &lt;code&gt;spec&lt;&#x2F;code&gt; snippet will be inserted on this file.&lt;&#x2F;p&gt;
&lt;p&gt;You can then proceed to writing the interesting part of your app. Or you can take a break, enjoying those 15 seconds of work you just avoided. You deserve it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;full-code&quot;&gt;Full code&lt;a class=&quot;zola-anchor&quot; href=&quot;#full-code&quot; aria-label=&quot;Anchor link for: full-code&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I avoided going through the entire vim code in this post, as that would&#x27;ve been a bit offtopic, and probably hard as well, given how much VimL sucks. All the vimscript code needed to reproduce my setup is right here for those who want it.&lt;&#x2F;p&gt;
&lt;p&gt;Feel free to &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;naps62&quot;&gt;reach me out through twitter&lt;&#x2F;a&gt; for any questions you might have, or bugs you might find, or checkout &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;naps62&#x2F;dotfiles&quot;&gt;my dotfiles&lt;&#x2F;a&gt; if you want to dig some more useful tips from there.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;augroup UltiSnips_custom
  autocmd!
  &amp;quot; autocmd User ProjectionistActivate silent! call skel#InsertSkeleton()
  autocmd BufNewFile * silent! call skel#InsertSkeleton()
augroup END

function s:try_insert(skel)
  execute &amp;quot;normal! i&amp;quot; . a:skel . &amp;quot;\&amp;lt;C-r&amp;gt;=UltiSnips#ExpandSnippet()\&amp;lt;CR&amp;gt;&amp;quot;

  if g:ulti_expand_res == 0
    silent! undo
    return
  endif

  &amp;quot; enter insert mode and advance cursor (equivalent to typing `a` instead of `i`)
  execute &amp;quot;startinsert&amp;quot;
  call cursor( line(&amp;#x27;.&amp;#x27;), col(&amp;#x27;.&amp;#x27;) + 1)

  return g:ulti_expand_res
endfunction

function! skel#InsertSkeleton() abort
  let filename = expand(&amp;#x27;%&amp;#x27;)

  &amp;quot; abort on non-empty buffer or exitant file
  if !(line(&amp;#x27;$&amp;#x27;) == 1 &amp;amp;&amp;amp; getline(&amp;#x27;$&amp;#x27;) == &amp;#x27;&amp;#x27;) || filereadable(filename)
    return
  endif

  if !empty(&amp;#x27;b:projectionist&amp;#x27;)
    &amp;quot; Loop through projections with &amp;#x27;skeleton&amp;#x27; key and try each one until the
    &amp;quot; snippet expands
    for [root, value] in projectionist#query(&amp;#x27;skeleton&amp;#x27;)
      echo value
      if s:try_insert(value)
        return
      endif
    endfor
  endif

  call s:try_insert(&amp;#x27;skel&amp;#x27;)
endfunction

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;What&#x27;s next?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;If you haven&#x27;t seen the prequels to this post, maybe now would be a good time to do so?&lt;&#x2F;p&gt;
&lt;p&gt;Check out &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;133-super-powered-vim-part-i-projections&quot;&gt;part I&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;134-super-powered-vim-part-ii-snippets&quot;&gt;part II&lt;&#x2F;a&gt; for more details on what projections and snippets are, and how to use them!&lt;&#x2F;p&gt;
&lt;p&gt;Or take a look at &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;blog&#x2F;posts&#x2F;tag&#x2F;development&quot;&gt;another post by one of our developers&lt;&#x2F;a&gt;. Happy coding!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Smarter heredoc syntax in vim</title>
        <published>2016-06-06T00:00:00+00:00</published>
        <updated>2016-06-06T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/smarter-heredoc-syntax-in-vim/" type="text/html"/>
        <id>https://naps62.com/posts/smarter-heredoc-syntax-in-vim/</id>
        
        <content type="html">&lt;p&gt;I have lately run into a problem with my editor of choice, vim (well, actually, it&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;neovim&#x2F;neovim&quot;&gt;neovim&lt;&#x2F;a&gt;), and the syntax highlighting in Ruby files.&lt;&#x2F;p&gt;
&lt;p&gt;Particularly, I ran into problems with the Heredoc syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-heredoc&quot;&gt;What is heredoc?&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-heredoc&quot; aria-label=&quot;Anchor link for: what-is-heredoc&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Long story short, it&#x27;s a feature present in many programming languages that lets you write multiline strings without all the hassle of dealing with quoting issues, newline characters, etc. Here&#x27;s an example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ruby&quot; class=&quot;language-ruby &quot;&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;puts &amp;lt;&amp;lt;HEREDOC
  a heredoc block can contain anything
  &amp;quot;even quotes.&amp;quot;
HEREDOC

## output:
  a heredoc block can contain anything
  &amp;quot;even quotes.&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of the placeholder &lt;code&gt;HEREDOC&lt;&#x2F;code&gt;, you can write any other name, as long as both ends match.&lt;&#x2F;p&gt;
&lt;p&gt;Ruby 2.3 also introduced the squiggly heredoc syntax, which strips off the indentation in every line, allowing you to keep your code indented without messing up the output, similar to rails&#x27; &lt;code&gt;strip_heredoc&lt;&#x2F;code&gt; method. But I&#x27;ll let Avdi Grimm explain that in his &lt;a href=&quot;http:&#x2F;&#x2F;devblog.avdi.org&#x2F;2016&#x2F;01&#x2F;06&#x2F;about-the-ruby-squiggly-heredoc-syntax&#x2F;&quot;&gt;own blog post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;heredoc-syntax-in-vim&quot;&gt;Heredoc syntax in vim&lt;a class=&quot;zola-anchor&quot; href=&quot;#heredoc-syntax-in-vim&quot; aria-label=&quot;Anchor link for: heredoc-syntax-in-vim&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Getting back to the subject, Ruby has 3 three different heredoc syntaxes. They&#x27;re mostly similar, but have slight differences:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;subvisual.s3.amazonaws.com&#x2F;blog&#x2F;post_image&#x2F;126&#x2F;image-1464871761215.png&quot; alt=&quot;file&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As you can see from the screenshot, at the time of writing, my vim setup has yet to recognize the new squiggly heredoc syntax, which is what prompted me to look for a fix.&lt;&#x2F;p&gt;
&lt;p&gt;I ended up finding a way to not only properly highlight the new syntax but also provide some powerful syntax highlighting to the heredoc content&#x27;s themselves:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;## ~&amp;#x2F;.vim&amp;#x2F;after&amp;#x2F;syntax&amp;#x2F;ruby.vim

let s:bcs = b:current_syntax
unlet b:current_syntax
syntax include @SQL syntax&amp;#x2F;sql.vim
let b:current_syntax = s:bcs

syntax region hereDocText    matchgroup=Statement start=+&amp;lt;&amp;lt;[-~.]*\z([A-Z]\+\)+ end=+^\s*\z1+ contains=NONE

syntax region hereDocDashSQL matchgroup=Statement start=+&amp;lt;&amp;lt;[-~.]*\z(SQLDOC\)+  end=+^\s*\z1+ contains=@SQL
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Place the above code in &lt;code&gt;~&#x2F;.vim&#x2F;after&#x2F;syntax&#x2F;ruby.vim&lt;&#x2F;code&gt;, and you&#x27;ll be able to do the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;subvisual.s3.amazonaws.com&#x2F;blog&#x2F;post_image&#x2F;127&#x2F;image-1464871768376.png&quot; alt=&quot;file&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The vim code did two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Told vim to match all heredoc syntaxes (using an appropriate RegEx), and use no highlight within it.;&lt;&#x2F;li&gt;
&lt;li&gt;When the heredoc keyword is &lt;code&gt;SQLDOC&lt;&#x2F;code&gt;, the inner text is highlighted as SQL code.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The same principle can be applied to create keywords for any syntax supported by vim. Here&#x27;s an example for both SQL and Shell Scripting:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;vim&quot; class=&quot;language-vim &quot;&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;let s:bcs = b:current_syntax
unlet b:current_syntax
syntax include @SQL syntax&amp;#x2F;sql.vim

&amp;quot; this unlet instruction is needed
&amp;quot; before we load each new syntax
unlet b:current_syntax
syntax include @SHELL syntax&amp;#x2F;sh.vim

let b:current_syntax = s:bcs

syntax region hereDocText    matchgroup=Statement start=+&amp;lt;&amp;lt;[-~.]*\z([A-Z]\+\)+ end=+^\s*\z1+ contains=NONE

syntax region hereDocDashSQL matchgroup=Statement start=+&amp;lt;&amp;lt;[-~.]*\z(SQLDOC\)+  end=+^\s*\z1+ contains=@SQL

syntax region hereDocDashShell matchgroup=Statement start=+&amp;lt;&amp;lt;[-~.]*\z(SHELLDOC\)+  end=+^\s*\z1+ contains=@SHELL
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only caveat here is that you&#x27;re forced to use a keyword that matches the syntax you want, and the fact that your coworkers won&#x27;t see any changes unless they also use Vim and apply this patch as well.&lt;&#x2F;p&gt;
&lt;p&gt;That being said, I believe it is still a very useful change nonetheless, and a great example of the capabilities of Vim.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-ruby-goodness&quot;&gt;More Ruby goodness&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-ruby-goodness&quot; aria-label=&quot;Anchor link for: more-ruby-goodness&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;If you&#x27;ve enjoyed this bit of knowledge you should really subscribe to &lt;a href=&quot;https:&#x2F;&#x2F;subvisual.co&#x2F;newsletter&#x2F;&quot;&gt;our newsletter&lt;&#x2F;a&gt;, where this and other great articles from the Web are shared every week.&lt;&#x2F;p&gt;
&lt;p&gt;If you want to meet us and&#x2F;or see some talks on Ruby topics, come join us at RubyConf Portugal 2016. For making all the way to the end of this article you get &lt;a href=&quot;https:&#x2F;&#x2F;ti.to&#x2F;subvisual&#x2F;rubyconfpt-2016&#x2F;discount&#x2F;good-reader-method&quot;&gt;25% off the price of the ticket&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Perfecting a CSS 3D Animation</title>
        <published>2015-07-17T00:00:00+00:00</published>
        <updated>2015-07-17T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/perfecting-a-css-3d-animation/" type="text/html"/>
        <id>https://naps62.com/posts/perfecting-a-css-3d-animation/</id>
        
        <summary type="html">&lt;p&gt;With recent advances in front end technologies, front end developers have been going crazy, pushing CSS to its limits and doing all sorts of &lt;a href=&quot;http:&#x2F;&#x2F;codepen.io&#x2F;azevedo-252&#x2F;pen&#x2F;rVvMXX&quot;&gt;beautiful animations&lt;&#x2F;a&gt;. Seriously, there are some &lt;a href=&quot;http:&#x2F;&#x2F;codepen.io&#x2F;fbrz&#x2F;pen&#x2F;whxbF&quot;&gt;crazy things&lt;&#x2F;a&gt; out there.&lt;&#x2F;p&gt;
&lt;p&gt;I recently did this &lt;a href=&quot;http:&#x2F;&#x2F;codepen.io&#x2F;naps62&#x2F;pen&#x2F;MwVRXZ&quot;&gt;3D animated atom&lt;&#x2F;a&gt; in which I had to employ a couple of weird techniques which I&#x27;ll try to explain here.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Easily Merging Pull Requests</title>
        <published>2014-11-24T00:00:00+00:00</published>
        <updated>2014-11-24T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://naps62.com/posts/easily-merging-pull-requests/" type="text/html"/>
        <id>https://naps62.com/posts/easily-merging-pull-requests/</id>
        
        <content type="html">&lt;p&gt;I try to automate all the annoying repetitive things I can. And not long ago, merging Pull Request was certainly on top of my list.&lt;&#x2F;p&gt;
&lt;p&gt;Whether it is for my own personal projects or within &lt;a href=&quot;https:&#x2F;&#x2F;www.groupbuddies.com&#x2F;&quot;&gt;Group Buddies&lt;&#x2F;a&gt;, the process is mostly the same all the time:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Update my local copy of the master branch&lt;&#x2F;strong&gt;, or whichever branch the pull request was targeting.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Go back to the branch I&#x27;m about to merge, and rebase it against master&lt;&#x2F;strong&gt;. Conflicts might show up here, and should be solved.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Merge the branch&lt;&#x2F;strong&gt;. By this point, not event the GitHub one-click merge is helpfull, since I would still have to push my local changes again (possibly using &lt;code&gt;-f&lt;&#x2F;code&gt; due to the rebase). Also, going back and forth between the browser is just tedious.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Delete the branch, both locally and remotely&lt;&#x2F;strong&gt;, since it is no longer needed.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Fortunately git is easily extensible. You can add subcommands to git by having executables following the appropriate naming convention &lt;code&gt;git-subcommand&lt;&#x2F;code&gt;, and placing them in your &lt;code&gt;$PATH&lt;&#x2F;code&gt;. So, for instance, whenever you call &lt;code&gt;git hello&lt;&#x2F;code&gt;, git will look for an executable called &lt;code&gt;git-hello&lt;&#x2F;code&gt;.
Zamith already covered this in his last post, &lt;a href=&quot;https:&#x2F;&#x2F;blog.groupbuddies.com&#x2F;posts&#x2F;43-supercharge-your-git&quot;&gt;Supercharge your git&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-goal&quot;&gt;The goal&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-goal&quot; aria-label=&quot;Anchor link for: the-goal&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Ultimately, I wanted to be able to just run &lt;code&gt;git close-pull-request&lt;&#x2F;code&gt; while on a feature branch, and have the command do all the work for me. I eventually aliased that to &lt;code&gt;git cpr&lt;&#x2F;code&gt;, since the name was obviously too long.&lt;&#x2F;p&gt;
&lt;p&gt;Another goal I had was portability. For these kind of work, I tend to stick with languages that are supported natively on any Linux distribution (like shell scripting or Perl). Since I do a fair amount of work on virtual machines, or even Raspberry Pi&#x27;s, it&#x27;s useful for me not to rely on Ruby for my workflow. This time, I went with shell scripting.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-script&quot;&gt;The script&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-script&quot; aria-label=&quot;Anchor link for: the-script&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the full script I wrote to close (the entire flow I described above):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;##!&amp;#x2F;bin&amp;#x2F;sh

current=$(git branchname)
destiny=${1:-master}

## 1. Update destiny
git fetch
git checkout $destiny
[[ $? == 0 ]] || exit &amp;quot;failed to switch to $destiny&amp;quot;
git rebase

## 2. rebase PR branch
git checkout $current
git rebase -i $destiny

## 3. merge
git checkout $destiny
git merge --ff-only $current
git push

## 4. remove branch
git nuke $current $destiny
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Don&#x27;t bother about the &lt;code&gt;git nuke&lt;&#x2F;code&gt; for now, it&#x27;s another custom command, and is explained below.
Let&#x27;s go through this one step at a time. First, I declare a couple of variables:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;current=$(git branchname)
destiny=${1:-master}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;variables&quot;&gt;Variables&lt;a class=&quot;zola-anchor&quot; href=&quot;#variables&quot; aria-label=&quot;Anchor link for: variables&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;current&lt;&#x2F;code&gt; variable gets the name of the current branch. which will be the one corresponding to the Pull Request I&#x27;m merging. For that I use another custom command &lt;code&gt;branchname&lt;&#x2F;code&gt;, which is simply the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;##!&amp;#x2F;bin&amp;#x2F;sh
git rev-parse --abbrev-ref HEAD
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And the &lt;code&gt;destiny&lt;&#x2F;code&gt; variable states the branch to which I want to merge, which comes from the first argument. That weird syntax (if you&#x27;re not familiar with shell scripting), indicates that if no argument is given, it will default to &lt;code&gt;master&lt;&#x2F;code&gt;, which is the value I want most of the time.&lt;&#x2F;p&gt;
&lt;p&gt;So by calling &lt;code&gt;git cpr&lt;&#x2F;code&gt; with no arguments, I&#x27;m merging with &lt;code&gt;master&lt;&#x2F;code&gt;, but I can override that by calling &lt;code&gt;git cpr other-branch&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;1-update-master&quot;&gt;1. Update master&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-update-master&quot; aria-label=&quot;Anchor link for: 1-update-master&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The first step is updating the master branch. This should be a simple fetch&#x2F;rebase. But in practice, I needed one extra check in between:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;[[ $? == 0 ]] || exit &amp;quot;failed to switch to $current&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is because, switching between branches with &lt;code&gt;checkout&lt;&#x2F;code&gt; might fail. For instance, if there are unstaged changes waiting to be committed. In this scenario, I want to play it safe and just abort the script with &lt;code&gt;exit&lt;&#x2F;code&gt;. No harm done.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2-rebase-branch&quot;&gt;2. Rebase branch&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-rebase-branch&quot; aria-label=&quot;Anchor link for: 2-rebase-branch&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;After that, I want to rebase the target branch against master. I do this with an interactive rebase, since I usually want to squash or reword some commits.
If there are conflicts, the rebase itself will abort and prevent the rest of the script from going on. When that happens, I have to solve the conflicts like I normally would, and then try the command again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3-merge&quot;&gt;3. Merge&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-merge&quot; aria-label=&quot;Anchor link for: 3-merge&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The third step involves going back to master and merging the branch. There is no rocket science here. I used the &lt;code&gt;--ff-only&lt;&#x2F;code&gt; option just to make sure I&#x27;m not creating a merge commit. That shouldn&#x27;t happen anyway since I&#x27;m rebasing both branches prior to the merge, but you can never be too safe.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;4-delete-the-feature-branch&quot;&gt;4. Delete the feature branch&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-delete-the-feature-branch&quot; aria-label=&quot;Anchor link for: 4-delete-the-feature-branch&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;For this I&#x27;m using yet another custom command. I extracted this since I ended up using it a lot to clean up old branches. Here it is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;branch=$1
destiny=${2:-master}
git checkout $destiny
git push --delete origin $branch &amp;gt; &amp;#x2F;dev&amp;#x2F;null &amp;amp;
git branch -D $branch
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I start by moving to another branch (to prevent problems when I trying to delete the branch I&#x27;m currently in). Then I just call the commands to delete both the remote branch on GitHub, and the local one.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m sending that to the background because it might take a second or two to finish, and I also don&#x27;t care for it&#x27;s output, which would show up randomly later since the terminal didn&#x27;t wait for it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading&lt;a class=&quot;zola-anchor&quot; href=&quot;#further-reading&quot; aria-label=&quot;Anchor link for: further-reading&quot;&gt;#&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There are a lot of suggestions out there on how to extend git, but a few I would recommend are &lt;a href=&quot;https:&#x2F;&#x2F;gitorious.org&#x2F;willgit&#x2F;mainline&#x2F;source&#x2F;a84bba3726a19bc78086852d54bb0219ea1bb6f9:bin&#x2F;git-wtf&quot;&gt;git-wtf&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;gitorious.org&#x2F;willgit&#x2F;mainline&#x2F;source&#x2F;a84bba3726a19bc78086852d54bb0219ea1bb6f9:bin&#x2F;git-publish-branch#L6&quot;&gt;git-publish-branch&lt;&#x2F;a&gt; (although the latter is not that much useful since the latest git updates).&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, I suggest you check out &lt;a href=&quot;https:&#x2F;&#x2F;hub.github.com&#x2F;&quot;&gt;hub&lt;&#x2F;a&gt;, or the newer and faster alternative, &lt;a href=&quot;https:&#x2F;&#x2F;owenou.com&#x2F;gh&#x2F;&quot;&gt;gh&lt;&#x2F;a&gt;. Both of these add extra functionality that might prevent you from having to write your own custom scripts.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
